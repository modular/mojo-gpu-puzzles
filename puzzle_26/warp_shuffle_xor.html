<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>🦋 warp.shuffle_xor() Butterfly Networks - Mojo 🔥 GPU Puzzles</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
            rel="stylesheet">
        
        <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
        
        <link rel="stylesheet" href="../theme/css/custom.css">
        <link rel="stylesheet" href="../theme/css/highlight.css">
        <link rel="stylesheet" id="theme">
        
        <!-- Additional meta tags -->
        <meta property="og:title" content="Mojo🔥 GPU Puzzles">
        <meta property="og:description" content="Learn GPU Programming in Mojo🔥 Through Interactive Puzzles">
        <meta property="og:image" content="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">
        <meta property="og:url" content="https://puzzles.modular.com/">
        <meta name="twitter:card" content="summary">
        <meta name="twitter:image:alt" content="Mojo GPU Puzzles Logo">
        <meta name="twitter:title" content="Mojo🔥 GPU Puzzles">
        <meta name="twitter:description" content="Learn GPU Programming in Mojo🔥 Through Interactive Puzzles">
        <meta name="twitter:image" content="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">
        <link rel="icon" type="image/png" href="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/css/custom.css">
        <link rel="stylesheet" href="../theme/css/highlight.css">
        <link rel="stylesheet" href="../theme/css/tabs.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <button class="collapse-sidebar" aria-label="Collapse sidebar"></button>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Toggle color mode and talk to us buttons -->
        <script>
            document.addEventListener('click', function (event) {
                if (!event.target.matches('.theme-toggle')) return;
                event.preventDefault();
                const prevTheme = theme;
                html.classList.remove(theme);
                const newTheme = prevTheme === 'ayu' ? 'light' : 'ayu'
                html.classList.add(newTheme);
                theme = newTheme
                localStorage.setItem('mdbook-theme', theme);
            }, false);
            document.addEventListener('click', function() {
                if (!event.target.matches('.log-in')) return;
                event.preventDefault();
                window.amplitude.logEvent('LoginClickedFromPuzzles');
                window.open('https://developer.modular.com', '_blank');
            });
        </script>

        <div class="page-header">
            <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                <i class="fa fa-bars"></i>
            </label>
            <div id="menu-bar" class="menu-bar">
                <div class="left-buttons">
                    <div class="logo-section">
                        <a class="desktop-logo-link" href="https://modular.com"></a>
                        <a class="mobile-logo-link" href="https://builds.modular.com"></a>
                        <div class="slash">/</div>
                        <a class="internal-link" ref="/">Puzzles</a>
                    </div>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                    </div>
                <div class="right-buttons">
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button theme-toggle-btn" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="false" aria-expanded="false">
                        <i class="theme-toggle"></i>
                    </button>
                    <a class="menu-btn print" href="../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a class="menu-btn" href="https://github.com/modular/mojo-gpu-puzzles" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                </div>
            </div>
        </div>

        <div id="page-wrapper" class="page-wrapper">
            <div class="page">

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <div id="content" class="content">
                    <main>
                        <h1 id="warpshuffle_xor-butterfly-communication"><a class="header" href="#warpshuffle_xor-butterfly-communication"><code>warp.shuffle_xor()</code> Butterfly Communication</a></h1>
<p>For warp-level butterfly communication we can use <code>shuffle_xor()</code> to create sophisticated tree-based communication patterns within a warp. This powerful primitive enables efficient parallel reductions, sorting networks, and advanced coordination algorithms without shared memory or explicit synchronization.</p>
<p><strong>Key insight:</strong> <em>The <a href="https://docs.modular.com/mojo/stdlib/gpu/warp/shuffle_xor">shuffle_xor()</a> operation leverages SIMT execution to create XOR-based communication trees, enabling efficient butterfly networks and parallel algorithms that scale with \(O(\log n)\) complexity relative to warp size.</em></p>
<blockquote>
<p><strong>What are butterfly networks?</strong> <a href="https://en.wikipedia.org/wiki/Butterfly_network">Butterfly networks</a> are communication topologies where threads exchange data based on XOR patterns of their indices. The name comes from the visual pattern when drawn - connections that look like butterfly wings. These networks are fundamental to parallel algorithms like FFT, bitonic sort, and parallel reductions because they enable \(O(\log n)\) communication complexity.</p>
</blockquote>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key concepts</a></h2>
<p>In this puzzle, you’ll learn:</p>
<ul>
<li><strong>XOR-based communication patterns</strong> with <code>shuffle_xor()</code></li>
<li><strong>Butterfly network topologies</strong> for parallel algorithms</li>
<li><strong>Tree-based parallel reductions</strong> with \(O(\log n)\) complexity</li>
<li><strong>Conditional butterfly operations</strong> for advanced coordination</li>
<li><strong>Hardware-optimized parallel primitives</strong> replacing complex shared memory</li>
</ul>
<p>The <code>shuffle_xor</code> operation enables each lane to exchange data with lanes based on <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> patterns:
\[\Large \text{shuffle_xor}(\text{value}, \text{mask}) = \text{value_from_lane}(\text{lane_id} \oplus \text{mask})\]</p>
<p>This transforms complex parallel algorithms into elegant butterfly communication patterns, enabling efficient tree reductions and sorting networks without explicit coordination.</p>
<h2 id="1-basic-butterfly-pair-swap"><a class="header" href="#1-basic-butterfly-pair-swap">1. Basic butterfly pair swap</a></h2>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<ul>
<li>Vector size: <code>SIZE = WARP_SIZE</code> (32 or 64 depending on GPU)</li>
<li>Grid configuration: <code>(1, 1)</code> blocks per grid</li>
<li>Block configuration: <code>(WARP_SIZE, 1)</code> threads per block</li>
<li>Data type: <code>DType.float32</code></li>
<li>Layout: <code>Layout.row_major(SIZE)</code> (1D row-major)</li>
</ul>
<h3 id="the-shuffle_xor-concept"><a class="header" href="#the-shuffle_xor-concept">The <code>shuffle_xor</code> concept</a></h3>
<p>Traditional pair swapping requires complex indexing and coordination:</p>
<pre><code class="language-mojo"># Traditional approach - complex and requires synchronization
shared_memory[lane] = input[global_i]
barrier()
if lane % 2 == 0:
    partner = lane + 1
else:
    partner = lane - 1
if partner &lt; WARP_SIZE:
    swapped_val = shared_memory[partner]
</code></pre>
<p><strong>Problems with traditional approach:</strong></p>
<ul>
<li><strong>Memory overhead</strong>: Requires shared memory allocation</li>
<li><strong>Synchronization</strong>: Needs explicit barriers</li>
<li><strong>Complex logic</strong>: Manual partner calculation and bounds checking</li>
<li><strong>Poor scaling</strong>: Doesn’t leverage hardware communication</li>
</ul>
<p>With <code>shuffle_xor()</code>, pair swapping becomes elegant:</p>
<pre><code class="language-mojo"># Butterfly XOR approach - simple and hardware-optimized
current_val = input[global_i]
swapped_val = shuffle_xor(current_val, 1)  # XOR with 1 creates pairs
output[global_i] = swapped_val
</code></pre>
<p><strong>Benefits of shuffle_xor:</strong></p>
<ul>
<li><strong>Zero memory overhead</strong>: Direct register-to-register communication</li>
<li><strong>No synchronization</strong>: SIMT execution guarantees correctness</li>
<li><strong>Hardware optimized</strong>: Single instruction for all lanes</li>
<li><strong>Butterfly foundation</strong>: Building block for complex parallel algorithms</li>
</ul>
<h3 id="code-to-complete"><a class="header" href="#code-to-complete">Code to complete</a></h3>
<p>Implement pair swapping using <code>shuffle_xor()</code> to exchange values between adjacent pairs.</p>
<p><strong>Mathematical operation:</strong> Create adjacent pairs that exchange values using XOR pattern:
\[\Large \text{output}[i] = \text{input}[i \oplus 1]\]</p>
<p>This transforms input data <code>[0, 1, 2, 3, 4, 5, 6, 7, ...]</code> into pairs <code>[1, 0, 3, 2, 5, 4, 7, 6, ...]</code>, where each pair <code>(i, i+1)</code> swaps values through XOR communication.</p>
<pre><code class="language-mojo">
</code></pre>
<p><a href="https://github.com/modular/mojo-gpu-puzzles/blob/main/problems/p26/p26.mojo" class="filename">View full file: problems/p26/p26.mojo</a></p>
<details>
<summary><strong>Tips</strong></summary>
<div class="solution-tips">
<h3 id="1-understanding-shuffle_xor"><a class="header" href="#1-understanding-shuffle_xor">1. <strong>Understanding shuffle_xor</strong></a></h3>
<p>The <code>shuffle_xor(value, mask)</code> operation allows each lane to exchange data with a lane whose ID differs by the XOR mask. Think about what happens when you XOR a lane ID with different mask values.</p>
<p><strong>Key question to explore:</strong></p>
<ul>
<li>What partner does lane 0 get when you XOR with mask 1?</li>
<li>What partner does lane 1 get when you XOR with mask 1?</li>
<li>Do you see a pattern forming?</li>
</ul>
<p><strong>Hint</strong>: Try working out the XOR operation manually for the first few lane IDs to understand the pairing pattern.</p>
<h3 id="2-xor-pair-pattern"><a class="header" href="#2-xor-pair-pattern">2. <strong>XOR pair pattern</strong></a></h3>
<p>Think about the binary representation of lane IDs and what happens when you flip the least significant bit.</p>
<p><strong>Questions to consider:</strong></p>
<ul>
<li>What happens to even-numbered lanes when you XOR with 1?</li>
<li>What happens to odd-numbered lanes when you XOR with 1?</li>
<li>Why does this create perfect pairs?</li>
</ul>
<h3 id="3-no-boundary-checking-needed"><a class="header" href="#3-no-boundary-checking-needed">3. <strong>No boundary checking needed</strong></a></h3>
<p>Unlike <code>shuffle_down()</code>, <code>shuffle_xor()</code> operations stay within warp boundaries. Consider why XOR with small masks never creates out-of-bounds lane IDs.</p>
<p><strong>Think about</strong>: What’s the maximum lane ID you can get when XORing any valid lane ID with 1?</p>
</div>
</details>
<p><strong>Test the butterfly pair swap:</strong></p>
<div class="code-tabs" data-tab-group="package-manager">
  <div class="tab-buttons">
    <button class="tab-button">pixi NVIDIA (default)</button>
    <button class="tab-button">pixi AMD</button>
    <button class="tab-button">uv</button>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p26 --pair-swap
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p26 --pair-swap -e amd
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">uv run poe p26 --pair-swap
</code></pre>
  </div>
</div>
<p>Expected output when solved:</p>
<pre><code class="language-txt">WARP_SIZE:  32
SIZE:  32
output: [1.0, 0.0, 3.0, 2.0, 5.0, 4.0, 7.0, 6.0, 9.0, 8.0, 11.0, 10.0, 13.0, 12.0, 15.0, 14.0, 17.0, 16.0, 19.0, 18.0, 21.0, 20.0, 23.0, 22.0, 25.0, 24.0, 27.0, 26.0, 29.0, 28.0, 31.0, 30.0]
expected: [1.0, 0.0, 3.0, 2.0, 5.0, 4.0, 7.0, 6.0, 9.0, 8.0, 11.0, 10.0, 13.0, 12.0, 15.0, 14.0, 17.0, 16.0, 19.0, 18.0, 21.0, 20.0, 23.0, 22.0, 25.0, 24.0, 27.0, 26.0, 29.0, 28.0, 31.0, 30.0]
✅ Butterfly pair swap test passed!
</code></pre>
<h3 id="solution"><a class="header" href="#solution">Solution</a></h3>
<details class="solution-details">
<summary></summary>
<pre><code class="language-mojo">fn butterfly_pair_swap[
    layout: Layout, size: Int
](
    output: LayoutTensor[mut=True, dtype, layout],
    input: LayoutTensor[mut=False, dtype, layout],
):
    """
    Basic butterfly pair swap: Exchange values between adjacent pairs using XOR pattern.
    Each thread exchanges its value with its XOR-1 neighbor, creating pairs: (0,1), (2,3), (4,5), etc.
    Uses shuffle_xor(val, 1) to swap values within each pair.
    This is the foundation of butterfly network communication patterns.
    """
    global_i = block_dim.x * block_idx.x + thread_idx.x

    if global_i &lt; size:
        current_val = input[global_i]

        # Exchange with XOR-1 neighbor using butterfly pattern
        # Lane 0 exchanges with lane 1, lane 2 with lane 3, etc.
        swapped_val = shuffle_xor(current_val, 1)

        # For demonstration, we'll store the swapped value
        # In real applications, this might be used for sorting, reduction, etc.
        output[global_i] = swapped_val


</code></pre>
<div class="solution-explanation">
<p>This solution demonstrates how <code>shuffle_xor()</code> creates perfect pair exchanges through XOR communication patterns.</p>
<p><strong>Algorithm breakdown:</strong></p>
<pre><code class="language-mojo">if global_i &lt; size:
    current_val = input[global_i]              # Each lane reads its element
    swapped_val = shuffle_xor(current_val, 1)  # XOR creates pair exchange

    # For demonstration, store the swapped value
    output[global_i] = swapped_val
</code></pre>
<p><strong>SIMT execution deep dive:</strong></p>
<pre><code>Cycle 1: All lanes load their values simultaneously
  Lane 0: current_val = input[0] = 0
  Lane 1: current_val = input[1] = 1
  Lane 2: current_val = input[2] = 2
  Lane 3: current_val = input[3] = 3
  ...
  Lane 31: current_val = input[31] = 31

Cycle 2: shuffle_xor(current_val, 1) executes on all lanes
  Lane 0: receives from Lane 1 (0⊕1=1) → swapped_val = 1
  Lane 1: receives from Lane 0 (1⊕1=0) → swapped_val = 0
  Lane 2: receives from Lane 3 (2⊕1=3) → swapped_val = 3
  Lane 3: receives from Lane 2 (3⊕1=2) → swapped_val = 2
  ...
  Lane 30: receives from Lane 31 (30⊕1=31) → swapped_val = 31
  Lane 31: receives from Lane 30 (31⊕1=30) → swapped_val = 30

Cycle 3: Store results
  Lane 0: output[0] = 1
  Lane 1: output[1] = 0
  Lane 2: output[2] = 3
  Lane 3: output[3] = 2
  ...
</code></pre>
<p><strong>Mathematical insight:</strong> This implements perfect pair exchange using XOR properties:
\[\Large \text{XOR}(i, 1) = \begin{cases}
i + 1 &amp; \text{if } i \bmod 2 = 0 \\
i - 1 &amp; \text{if } i \bmod 2 = 1
\end{cases}\]</p>
<p><strong>Why shuffle_xor is superior:</strong></p>
<ol>
<li><strong>Perfect symmetry</strong>: Every lane participates in exactly one pair</li>
<li><strong>No coordination</strong>: All pairs exchange simultaneously</li>
<li><strong>Hardware optimized</strong>: Single instruction for entire warp</li>
<li><strong>Butterfly foundation</strong>: Building block for complex parallel algorithms</li>
</ol>
<p><strong>Performance characteristics:</strong></p>
<ul>
<li><strong>Latency</strong>: 1 cycle (hardware register exchange)</li>
<li><strong>Bandwidth</strong>: 0 bytes (no memory traffic)</li>
<li><strong>Parallelism</strong>: All WARP_SIZE lanes exchange simultaneously</li>
<li><strong>Scalability</strong>: \(O(1)\) complexity regardless of data size</li>
</ul>
</div>
</details>
<h2 id="2-butterfly-parallel-maximum"><a class="header" href="#2-butterfly-parallel-maximum">2. Butterfly parallel maximum</a></h2>
<h3 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h3>
<ul>
<li>Vector size: <code>SIZE = WARP_SIZE</code> (32 or 64 depending on GPU)</li>
<li>Grid configuration: <code>(1, 1)</code> blocks per grid</li>
<li>Block configuration: <code>(WARP_SIZE, 1)</code> threads per block</li>
</ul>
<h3 id="code-to-complete-1"><a class="header" href="#code-to-complete-1">Code to complete</a></h3>
<p>Implement parallel maximum reduction using butterfly <code>shuffle_xor</code> with decreasing offsets.</p>
<p><strong>Mathematical operation:</strong> Compute the maximum across all warp lanes using tree reduction:
\[\Large \text{max_result} = \max_{i=0}^{\small\text{WARP_SIZE}-1} \text{input}[i]\]</p>
<p><strong>Butterfly reduction pattern:</strong> Use XOR offsets starting from <code>WARP_SIZE/2</code> down to <code>1</code> to create a binary tree where each step halves the active communication range:</p>
<ul>
<li><strong>Step 1</strong>: Compare with lanes <code>WARP_SIZE/2</code> positions away (covers full warp)</li>
<li><strong>Step 2</strong>: Compare with lanes <code>WARP_SIZE/4</code> positions away (covers remaining range)</li>
<li><strong>Step 3</strong>: Compare with lanes <code>WARP_SIZE/8</code> positions away</li>
<li><strong>Step 4</strong>: Continue halving until <code>offset = 1</code></li>
</ul>
<p>After \(\log_2(\text{WARP_SIZE})\) steps, all lanes have the global maximum. This works for any <code>WARP_SIZE</code> (32, 64, etc.).</p>
<pre><code class="language-mojo">fn butterfly_parallel_max[
    layout: Layout, size: Int
](
    output: LayoutTensor[mut=True, dtype, layout],
    input: LayoutTensor[mut=False, dtype, layout],
):
    """
    Parallel maximum reduction using butterfly pattern.
    Uses shuffle_xor with decreasing offsets starting from WARP_SIZE/2 down to 1.
    Each step reduces the active range by half until all threads have the maximum value.
    This implements an efficient O(log n) parallel reduction algorithm that works
    for any WARP_SIZE (32, 64, etc.).
    """
    global_i = block_dim.x * block_idx.x + thread_idx.x

    # FILL ME IN (roughly 7 lines)


</code></pre>
<details>
<summary><strong>Tips</strong></summary>
<div class="solution-tips">
<h3 id="1-understanding-butterfly-reduction"><a class="header" href="#1-understanding-butterfly-reduction">1. <strong>Understanding butterfly reduction</strong></a></h3>
<p>The butterfly reduction creates a binary tree communication pattern. Think about how you can systematically reduce the problem size at each step.</p>
<p><strong>Key questions:</strong></p>
<ul>
<li>What should be your starting offset to cover the maximum range?</li>
<li>How should the offset change between steps?</li>
<li>When should you stop the reduction?</li>
</ul>
<p><strong>Hint</strong>: The name “butterfly” comes from the communication pattern - try sketching it out for a small example.</p>
<h3 id="2-xor-reduction-properties"><a class="header" href="#2-xor-reduction-properties">2. <strong>XOR reduction properties</strong></a></h3>
<p>XOR creates non-overlapping communication pairs at each step. Consider why this is important for parallel reductions.</p>
<p><strong>Think about:</strong></p>
<ul>
<li>How does XOR with different offsets create different communication patterns?</li>
<li>Why don’t lanes interfere with each other at the same step?</li>
<li>What makes XOR particularly well-suited for tree reductions?</li>
</ul>
<h3 id="3-accumulating-maximum-values"><a class="header" href="#3-accumulating-maximum-values">3. <strong>Accumulating maximum values</strong></a></h3>
<p>Each lane needs to progressively build up knowledge of the maximum value in its “region”.</p>
<p><strong>Algorithm structure:</strong></p>
<ul>
<li>Start with your own value</li>
<li>At each step, compare with a neighbor’s value</li>
<li>Keep the maximum and continue</li>
</ul>
<p><strong>Key insight</strong>: After each step, your “region of knowledge” doubles in size.</p>
<ul>
<li>After final step: Each lane knows global maximum</li>
</ul>
<h3 id="4-why-this-pattern-works"><a class="header" href="#4-why-this-pattern-works">4. <strong>Why this pattern works</strong></a></h3>
<p>The butterfly reduction guarantees that after \(\log_2(\text{WARP\_SIZE})\) steps:</p>
<ul>
<li><strong>Every lane</strong> has seen <strong>every other lane’s</strong> value indirectly</li>
<li><strong>No redundant communication</strong>: Each pair exchanges exactly once per step</li>
<li><strong>Optimal complexity</strong>: \(O(\log n)\) steps instead of \(O(n)\) sequential comparison</li>
</ul>
<p><strong>Trace example</strong> (4 lanes, values [3, 1, 7, 2]):</p>
<pre><code>Initial: Lane 0=3, Lane 1=1, Lane 2=7, Lane 3=2

Step 1 (offset=2): 0 ↔ 2, 1 ↔ 3
  Lane 0: max(3, 7) = 7
  Lane 1: max(1, 2) = 2
  Lane 2: max(7, 3) = 7
  Lane 3: max(2, 1) = 2

Step 2 (offset=1): 0 ↔ 1, 2 ↔ 3
  Lane 0: max(7, 2) = 7
  Lane 1: max(2, 7) = 7
  Lane 2: max(7, 2) = 7
  Lane 3: max(2, 7) = 7

Result: All lanes have global maximum = 7
</code></pre>
</div>
</details>
<p><strong>Test the butterfly parallel maximum:</strong></p>
<div class="code-tabs" data-tab-group="package-manager">
  <div class="tab-buttons">
    <button class="tab-button">pixi NVIDIA (default)</button>
    <button class="tab-button">pixi AMD</button>
    <button class="tab-button">uv</button>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p26 --parallel-max
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p26 --parallel-max -e amd
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">uv run poe p26 --parallel-max
</code></pre>
  </div>
</div>
<p>Expected output when solved:</p>
<pre><code class="language-txt">WARP_SIZE:  32
SIZE:  32
output: [1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0]
expected: [1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0, 1000.0]
✅ Butterfly parallel max test passed!
</code></pre>
<h3 id="solution-1"><a class="header" href="#solution-1">Solution</a></h3>
<details class="solution-details">
<summary></summary>
<pre><code class="language-mojo">fn butterfly_parallel_max[
    layout: Layout, size: Int
](
    output: LayoutTensor[mut=True, dtype, layout],
    input: LayoutTensor[mut=False, dtype, layout],
):
    """
    Parallel maximum reduction using butterfly pattern.
    Uses shuffle_xor with decreasing offsets (16, 8, 4, 2, 1) to perform tree-based reduction.
    Each step reduces the active range by half until all threads have the maximum value.
    This implements an efficient O(log n) parallel reduction algorithm.
    """
    global_i = block_dim.x * block_idx.x + thread_idx.x

    if global_i &lt; size:
        max_val = input[global_i]

        # Butterfly reduction tree: dynamic for any WARP_SIZE (32, 64, etc.)
        # Start with half the warp size and reduce by half each step
        offset = WARP_SIZE // 2
        while offset &gt; 0:
            max_val = max(max_val, shuffle_xor(max_val, offset))
            offset //= 2

        # All threads now have the maximum value across the entire warp
        output[global_i] = max_val


</code></pre>
<div class="solution-explanation">
<p>This solution demonstrates how <code>shuffle_xor()</code> creates efficient parallel reduction trees with \(O(\log n)\) complexity.</p>
<p><strong>Complete algorithm analysis:</strong></p>
<pre><code class="language-mojo">if global_i &lt; size:
    max_val = input[global_i]  # Start with local value

    # Butterfly reduction tree: dynamic for any WARP_SIZE
    offset = WARP_SIZE // 2
    while offset &gt; 0:
        max_val = max(max_val, shuffle_xor(max_val, offset))
        offset //= 2

    output[global_i] = max_val  # All lanes have global maximum
</code></pre>
<p><strong>Butterfly execution trace (8-lane example, values [0,2,4,6,8,10,12,1000]):</strong></p>
<pre><code>Initial state:
  Lane 0: max_val = 0,    Lane 1: max_val = 2
  Lane 2: max_val = 4,    Lane 3: max_val = 6
  Lane 4: max_val = 8,    Lane 5: max_val = 10
  Lane 6: max_val = 12,   Lane 7: max_val = 1000

Step 1: shuffle_xor(max_val, 4) - Halves exchange
  Lane 0↔4: max(0,8)=8,     Lane 1↔5: max(2,10)=10
  Lane 2↔6: max(4,12)=12,   Lane 3↔7: max(6,1000)=1000
  Lane 4↔0: max(8,0)=8,     Lane 5↔1: max(10,2)=10
  Lane 6↔2: max(12,4)=12,   Lane 7↔3: max(1000,6)=1000

Step 2: shuffle_xor(max_val, 2) - Quarters exchange
  Lane 0↔2: max(8,12)=12,   Lane 1↔3: max(10,1000)=1000
  Lane 2↔0: max(12,8)=12,   Lane 3↔1: max(1000,10)=1000
  Lane 4↔6: max(8,12)=12,   Lane 5↔7: max(10,1000)=1000
  Lane 6↔4: max(12,8)=12,   Lane 7↔5: max(1000,10)=1000

Step 3: shuffle_xor(max_val, 1) - Pairs exchange
  Lane 0↔1: max(12,1000)=1000,  Lane 1↔0: max(1000,12)=1000
  Lane 2↔3: max(12,1000)=1000,  Lane 3↔2: max(1000,12)=1000
  Lane 4↔5: max(12,1000)=1000,  Lane 5↔4: max(1000,12)=1000
  Lane 6↔7: max(12,1000)=1000,  Lane 7↔6: max(1000,12)=1000

Final result: All lanes have max_val = 1000
</code></pre>
<p><strong>Mathematical insight:</strong> This implements the parallel reduction operator with butterfly communication:
\[\Large \text{Reduce}(\oplus, [a_0, a_1, \ldots, a_{n-1}]) = a_0 \oplus a_1 \oplus \cdots \oplus a_{n-1}\]</p>
<p>Where \(\oplus\) is the <code>max</code> operation and the butterfly pattern ensures optimal \(O(\log n)\) complexity.</p>
<p><strong>Why butterfly reduction is superior:</strong></p>
<ol>
<li><strong>Logarithmic complexity</strong>: \(O(\log n)\) vs \(O(n)\) for sequential reduction</li>
<li><strong>Perfect load balancing</strong>: Every lane participates equally at each step</li>
<li><strong>No memory bottlenecks</strong>: Pure register-to-register communication</li>
<li><strong>Hardware optimized</strong>: Maps directly to GPU butterfly networks</li>
</ol>
<p><strong>Performance characteristics:</strong></p>
<ul>
<li><strong>Steps</strong>: \(\log_2(\text{WARP_SIZE})\) (e.g., 5 for 32-thread, 6 for 64-thread warp)</li>
<li><strong>Latency per step</strong>: 1 cycle (register exchange + comparison)</li>
<li><strong>Total latency</strong>: \(\log_2(\text{WARP_SIZE})\) cycles vs \((\text{WARP_SIZE}-1)\) cycles for sequential</li>
<li><strong>Parallelism</strong>: All lanes active throughout the algorithm</li>
</ul>
</div>
</details>
<h2 id="3-butterfly-conditional-maximum"><a class="header" href="#3-butterfly-conditional-maximum">3. Butterfly conditional maximum</a></h2>
<h3 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h3>
<ul>
<li>Vector size: <code>SIZE_2 = 64</code> (multi-block scenario)</li>
<li>Grid configuration: <code>BLOCKS_PER_GRID_2 = (2, 1)</code> blocks per grid</li>
<li>Block configuration: <code>THREADS_PER_BLOCK_2 = (WARP_SIZE, 1)</code> threads per block</li>
</ul>
<h3 id="code-to-complete-2"><a class="header" href="#code-to-complete-2">Code to complete</a></h3>
<p>Implement conditional butterfly reduction where even lanes store the maximum and odd lanes store the minimum.</p>
<p><strong>Mathematical operation:</strong> Perform butterfly reduction for both maximum and minimum, then conditionally output based on lane parity:
\[\Large \text{output}[i] = \begin{cases}
\max_{j=0}^{\text{WARP_SIZE}-1} \text{input}[j] &amp; \text{if } i \bmod 2 = 0 \\
\min_{j=0}^{\text{WARP_SIZE}-1} \text{input}[j] &amp; \text{if } i \bmod 2 = 1
\end{cases}\]</p>
<p><strong>Dual reduction pattern:</strong> Simultaneously track both maximum and minimum values through the butterfly tree, then conditionally output based on lane ID parity. This demonstrates how butterfly patterns can be extended for complex multi-value reductions.</p>
<pre><code class="language-mojo">alias SIZE_2 = 64
alias BLOCKS_PER_GRID_2 = (2, 1)
alias THREADS_PER_BLOCK_2 = (WARP_SIZE, 1)
alias layout_2 = Layout.row_major(SIZE_2)


fn butterfly_conditional_max[
    layout: Layout, size: Int
](
    output: LayoutTensor[mut=True, dtype, layout],
    input: LayoutTensor[mut=False, dtype, layout],
):
    """
    Conditional butterfly maximum: Perform butterfly max reduction, but only store result
    in even-numbered lanes. Odd-numbered lanes store the minimum value seen.
    Demonstrates conditional logic combined with butterfly communication patterns.
    """
    global_i = block_dim.x * block_idx.x + thread_idx.x
    lane = lane_id()

    if global_i &lt; size:
        current_val = input[global_i]
        min_val = current_val

        # FILL ME IN (roughly 11 lines)


</code></pre>
<details>
<summary><strong>Tips</strong></summary>
<div class="solution-tips">
<h3 id="1-dual-track-butterfly-reduction"><a class="header" href="#1-dual-track-butterfly-reduction">1. <strong>Dual-track butterfly reduction</strong></a></h3>
<p>This puzzle requires tracking TWO different values simultaneously through the butterfly tree. Think about how you can run multiple reductions in parallel.</p>
<p><strong>Key questions:</strong></p>
<ul>
<li>How can you maintain both maximum and minimum values during the reduction?</li>
<li>Can you use the same butterfly pattern for both operations?</li>
<li>What variables do you need to track?</li>
</ul>
<h3 id="2-conditional-output-logic"><a class="header" href="#2-conditional-output-logic">2. <strong>Conditional output logic</strong></a></h3>
<p>After completing the butterfly reduction, you need to output different values based on lane parity.</p>
<p><strong>Consider:</strong></p>
<ul>
<li>How do you determine if a lane is even or odd?</li>
<li>Which lanes should output the maximum vs minimum?</li>
<li>How do you access the lane ID?</li>
</ul>
<h3 id="3-butterfly-reduction-for-both-min-and-max"><a class="header" href="#3-butterfly-reduction-for-both-min-and-max">3. <strong>Butterfly reduction for both min and max</strong></a></h3>
<p>The challenge is efficiently computing both min and max in parallel using the same butterfly communication pattern.</p>
<p><strong>Think about:</strong></p>
<ul>
<li>Do you need separate shuffle operations for min and max?</li>
<li>Can you reuse the same neighbor values for both operations?</li>
<li>How do you ensure both reductions complete correctly?</li>
</ul>
<h3 id="4-multi-block-boundary-considerations"><a class="header" href="#4-multi-block-boundary-considerations">4. <strong>Multi-block boundary considerations</strong></a></h3>
<p>This puzzle uses multiple blocks. Consider how this affects the reduction scope.</p>
<p><strong>Important considerations:</strong></p>
<ul>
<li>What’s the scope of each butterfly reduction?</li>
<li>How does the block structure affect lane numbering?</li>
<li>Are you computing global or per-block min/max values?</li>
</ul>
</div>
</details>
<p><strong>Test the butterfly conditional maximum:</strong></p>
<div class="code-tabs" data-tab-group="package-manager">
  <div class="tab-buttons">
    <button class="tab-button">pixi NVIDIA (default)</button>
    <button class="tab-button">pixi AMD</button>
    <button class="tab-button">uv</button>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p26 --conditional-max
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p26 --conditional-max -e amd
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">uv run poe p26 --conditional-max
</code></pre>
  </div>
</div>
<p>Expected output when solved:</p>
<pre><code class="language-txt">WARP_SIZE:  32
SIZE_2:  64
output: [9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0]
expected: [9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 9.0, 0.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0, 63.0, 32.0]
✅ Butterfly conditional max test passed!
</code></pre>
<h3 id="solution-2"><a class="header" href="#solution-2">Solution</a></h3>
<details class="solution-details">
<summary></summary>
<pre><code class="language-mojo">fn butterfly_conditional_max[
    layout: Layout, size: Int
](
    output: LayoutTensor[mut=True, dtype, layout],
    input: LayoutTensor[mut=False, dtype, layout],
):
    """
    Conditional butterfly maximum: Perform butterfly max reduction, but only store result
    in even-numbered lanes. Odd-numbered lanes store the minimum value seen.
    Demonstrates conditional logic combined with butterfly communication patterns.
    """
    global_i = block_dim.x * block_idx.x + thread_idx.x
    lane = lane_id()

    if global_i &lt; size:
        current_val = input[global_i]
        min_val = current_val

        # Butterfly reduction for both maximum and minimum: dynamic for any WARP_SIZE
        offset = WARP_SIZE // 2
        while offset &gt; 0:
            neighbor_val = shuffle_xor(current_val, offset)
            current_val = max(current_val, neighbor_val)

            min_neighbor_val = shuffle_xor(min_val, offset)
            min_val = min(min_val, min_neighbor_val)

            offset //= 2

        # Conditional output: max for even lanes, min for odd lanes
        if lane % 2 == 0:
            output[global_i] = current_val  # Maximum
        else:
            output[global_i] = min_val  # Minimum


</code></pre>
<div class="solution-explanation">
<p>This solution demonstrates advanced butterfly reduction with dual tracking and conditional output.</p>
<p><strong>Complete algorithm analysis:</strong></p>
<pre><code class="language-mojo">if global_i &lt; size:
    current_val = input[global_i]
    min_val = current_val  # Track minimum separately

    # Butterfly reduction for both max and min log_2(WARP_SIZE}) steps)
    offset = WARP_SIZE // 2
    while offset &gt; 0:
        neighbor_val = shuffle_xor(current_val, offset)
        current_val = max(current_val, neighbor_val)    # Max reduction

        min_neighbor_val = shuffle_xor(min_val, offset)
        min_val = min(min_val, min_neighbor_val)        # Min reduction

        offset //= 2

    # Conditional output based on lane parity
    if lane % 2 == 0:
        output[global_i] = current_val  # Even lanes: maximum
    else:
        output[global_i] = min_val      # Odd lanes: minimum
</code></pre>
<p><strong>Dual reduction execution trace (4-lane example, values [3, 1, 7, 2]):</strong></p>
<pre><code>Initial state:
  Lane 0: current_val=3, min_val=3
  Lane 1: current_val=1, min_val=1
  Lane 2: current_val=7, min_val=7
  Lane 3: current_val=2, min_val=2

Step 1: shuffle_xor(current_val, 2) and shuffle_xor(min_val, 2) - Halves exchange
  Lane 0↔2: max_neighbor=7, min_neighbor=7 → current_val=max(3,7)=7, min_val=min(3,7)=3
  Lane 1↔3: max_neighbor=2, min_neighbor=2 → current_val=max(1,2)=2, min_val=min(1,2)=1
  Lane 2↔0: max_neighbor=3, min_neighbor=3 → current_val=max(7,3)=7, min_val=min(7,3)=3
  Lane 3↔1: max_neighbor=1, min_neighbor=1 → current_val=max(2,1)=2, min_val=min(2,1)=1

Step 2: shuffle_xor(current_val, 1) and shuffle_xor(min_val, 1) - Pairs exchange
  Lane 0↔1: max_neighbor=2, min_neighbor=1 → current_val=max(7,2)=7, min_val=min(3,1)=1
  Lane 1↔0: max_neighbor=7, min_neighbor=3 → current_val=max(2,7)=7, min_val=min(1,3)=1
  Lane 2↔3: max_neighbor=2, min_neighbor=1 → current_val=max(7,2)=7, min_val=min(3,1)=1
  Lane 3↔2: max_neighbor=7, min_neighbor=3 → current_val=max(2,7)=7, min_val=min(1,3)=1

Final result: All lanes have current_val=7 (global max) and min_val=1 (global min)
</code></pre>
<p><strong>Dynamic algorithm</strong> (works for any WARP_SIZE):</p>
<pre><code class="language-mojo">offset = WARP_SIZE // 2
while offset &gt; 0:
    neighbor_val = shuffle_xor(current_val, offset)
    current_val = max(current_val, neighbor_val)

    min_neighbor_val = shuffle_xor(min_val, offset)
    min_val = min(min_val, min_neighbor_val)

    offset //= 2
</code></pre>
<p><strong>Mathematical insight:</strong> This implements dual parallel reduction with conditional demultiplexing:
\[\Large \begin{align}
\text{max_result} &amp;= \max_{i=0}^{n-1} \text{input}[i] \\
\text{min_result} &amp;= \min_{i=0}^{n-1} \text{input}[i] \\
\text{output}[i] &amp;= \text{lane_parity}(i) \; \text{?} \; \text{min_result} : \text{max_result}
\end{align}\]</p>
<p><strong>Why dual butterfly reduction works:</strong></p>
<ol>
<li><strong>Independent reductions</strong>: Max and min reductions are mathematically independent</li>
<li><strong>Parallel execution</strong>: Both can use the same butterfly communication pattern</li>
<li><strong>Shared communication</strong>: Same shuffle operations serve both reductions</li>
<li><strong>Conditional output</strong>: Lane parity determines which result to output</li>
</ol>
<p><strong>Performance characteristics:</strong></p>
<ul>
<li><strong>Communication steps</strong>: \(\log_2(\text{WARP_SIZE})\) (same as single reduction)</li>
<li><strong>Computation per step</strong>: 2 operations (max + min) vs 1 for single reduction</li>
<li><strong>Memory efficiency</strong>: 2 registers per thread vs complex shared memory approaches</li>
<li><strong>Output flexibility</strong>: Different lanes can output different reduction results</li>
</ul>
</div>
</details>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The <code>shuffle_xor()</code> primitive enables powerful butterfly communication patterns that form the foundation of efficient parallel algorithms. Through these three problems, you’ve learned:</p>
<h3 id="core-butterfly-patterns"><a class="header" href="#core-butterfly-patterns"><strong>Core Butterfly Patterns</strong></a></h3>
<ol>
<li>
<p><strong>Pair Exchange</strong> (<code>shuffle_xor(value, 1)</code>):</p>
<ul>
<li>Creates perfect adjacent pairs: (0,1), (2,3), (4,5), …</li>
<li>\(O(1)\) complexity with zero memory overhead</li>
<li>Foundation for sorting networks and data reorganization</li>
</ul>
</li>
<li>
<p><strong>Tree Reduction</strong> (dynamic offsets: <code>WARP_SIZE/2</code> → <code>1</code>):</p>
<ul>
<li>Logarithmic parallel reduction: \(O(\log n)\) vs \(O(n)\) sequential</li>
<li>Works for any associative operation (max, min, sum, etc.)</li>
<li>Optimal load balancing across all warp lanes</li>
</ul>
</li>
<li>
<p><strong>Conditional Multi-Reduction</strong> (dual tracking + lane parity):</p>
<ul>
<li>Simultaneous multiple reductions in parallel</li>
<li>Conditional output based on thread characteristics</li>
<li>Advanced coordination without explicit synchronization</li>
</ul>
</li>
</ol>
<h3 id="key-algorithmic-insights"><a class="header" href="#key-algorithmic-insights"><strong>Key Algorithmic Insights</strong></a></h3>
<p><strong>XOR Communication Properties:</strong></p>
<ul>
<li><code>shuffle_xor(value, mask)</code> creates symmetric, non-overlapping pairs</li>
<li>Each mask creates a unique communication topology</li>
<li>Butterfly networks emerge naturally from binary XOR patterns</li>
</ul>
<p><strong>Dynamic Algorithm Design:</strong></p>
<pre><code class="language-mojo">offset = WARP_SIZE // 2
while offset &gt; 0:
    neighbor_val = shuffle_xor(current_val, offset)
    current_val = operation(current_val, neighbor_val)
    offset //= 2
</code></pre>
<p><strong>Performance Advantages:</strong></p>
<ul>
<li><strong>Hardware optimization</strong>: Direct register-to-register communication</li>
<li><strong>No synchronization</strong>: SIMT execution guarantees correctness</li>
<li><strong>Scalable complexity</strong>: \(O(\log n)\) for any WARP_SIZE (32, 64, etc.)</li>
<li><strong>Memory efficiency</strong>: Zero shared memory requirements</li>
</ul>
<h3 id="practical-applications"><a class="header" href="#practical-applications"><strong>Practical Applications</strong></a></h3>
<p>These butterfly patterns are fundamental to:</p>
<ul>
<li><strong>Parallel reductions</strong>: Sum, max, min, logical operations</li>
<li><strong>Prefix/scan operations</strong>: Cumulative sums, parallel sorting</li>
<li><strong>FFT algorithms</strong>: Signal processing and convolution</li>
<li><strong>Bitonic sorting</strong>: Parallel sorting networks</li>
<li><strong>Graph algorithms</strong>: Tree traversals and connectivity</li>
</ul>
<p>The <code>shuffle_xor()</code> primitive transforms complex parallel coordination into elegant, hardware-optimized communication patterns that scale efficiently across different GPU architectures.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../puzzle_26/puzzle_26.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../puzzle_26/warp_prefix_sum.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../puzzle_26/puzzle_26.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../puzzle_26/warp_prefix_sum.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/mojolang.js"></script>
        <script src="../theme/sidebar.js"></script>
        <script src="../theme/solution.js"></script>
        <script src="../theme/init-amplitude.js"></script>
        <script src="../theme/tabs.js"></script>


    </div>
    </body>
</html>
