<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>vectorize - SIMD Control - Mojo 🔥 GPU Puzzles</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
            rel="stylesheet">
        
        <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
        
        <link rel="stylesheet" href="../theme/css/custom.css">
        <link rel="stylesheet" href="../theme/css/highlight.css">
        <link rel="stylesheet" id="theme">
        
        <!-- Additional meta tags -->
        <meta property="og:title" content="Mojo🔥 GPU Puzzles">
        <meta property="og:description" content="Learn GPU Programming in Mojo🔥 Through Interactive Puzzles">
        <meta property="og:image" content="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">
        <meta property="og:url" content="https://puzzles.modular.com/">
        <meta name="twitter:card" content="summary">
        <meta name="twitter:image:alt" content="Mojo GPU Puzzles Logo">
        <meta name="twitter:title" content="Mojo🔥 GPU Puzzles">
        <meta name="twitter:description" content="Learn GPU Programming in Mojo🔥 Through Interactive Puzzles">
        <meta name="twitter:image" content="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">
        <link rel="icon" type="image/png" href="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/css/custom.css">
        <link rel="stylesheet" href="../theme/css/highlight.css">
        <link rel="stylesheet" href="../theme/css/tabs.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <button class="collapse-sidebar" aria-label="Collapse sidebar"></button>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Toggle color mode and talk to us buttons -->
        <script>
            document.addEventListener('click', function (event) {
                if (!event.target.matches('.theme-toggle')) return;
                event.preventDefault();
                const prevTheme = theme;
                html.classList.remove(theme);
                const newTheme = prevTheme === 'ayu' ? 'light' : 'ayu'
                html.classList.add(newTheme);
                theme = newTheme
                localStorage.setItem('mdbook-theme', theme);
            }, false);
            document.addEventListener('click', function() {
                if (!event.target.matches('.log-in')) return;
                event.preventDefault();
                window.amplitude.logEvent('LoginClickedFromPuzzles');
                window.open('https://developer.modular.com', '_blank');
            });
        </script>

        <div class="page-header">
            <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                <i class="fa fa-bars"></i>
            </label>
            <div id="menu-bar" class="menu-bar">
                <div class="left-buttons">
                    <div class="logo-section">
                        <a class="desktop-logo-link" href="https://modular.com"></a>
                        <a class="mobile-logo-link" href="https://builds.modular.com"></a>
                        <div class="slash">/</div>
                        <a class="internal-link" ref="/">Puzzles</a>
                    </div>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                    </div>
                <div class="right-buttons">
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button theme-toggle-btn" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="false" aria-expanded="false">
                        <i class="theme-toggle"></i>
                    </button>
                    <a class="menu-btn print" href="../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a class="menu-btn" href="https://github.com/modular/mojo-gpu-puzzles" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                    <button class="secondary-btn log-in">Log in</button>
                </div>
            </div>
        </div>

        <div id="page-wrapper" class="page-wrapper">
            <div class="page">

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <div id="content" class="content">
                    <main>
                        <h1 id="vectorization---fine-grained-simd-control"><a class="header" href="#vectorization---fine-grained-simd-control">Vectorization - Fine-Grained SIMD Control</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This puzzle explores <strong>advanced vectorization techniques</strong> using manual vectorization and <a href="https://docs.modular.com/mojo/stdlib/algorithm/functional/vectorize/">vectorize</a> that give you precise control over SIMD operations within GPU kernels. You’ll implement two different approaches to vectorized computation:</p>
<ol>
<li><strong>Manual vectorization</strong>: Direct SIMD control with explicit index calculations</li>
<li><strong>Mojo’s vectorize function</strong>: High-level vectorization with automatic bounds checking</li>
</ol>
<p>Both approaches build on tiling concepts but with different trade-offs between control, safety, and performance optimization.</p>
<p><strong>Key insight:</strong> <em>Different vectorization strategies suit different performance requirements and complexity levels.</em></p>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key concepts</a></h2>
<p>In this puzzle, you’ll master:</p>
<ul>
<li><strong>Manual SIMD operations</strong> with explicit index management</li>
<li><strong>Mojo’s vectorize function</strong> for safe, automatic vectorization</li>
<li><strong>Chunk-based memory organization</strong> for optimal SIMD alignment</li>
<li><strong>Bounds checking strategies</strong> for edge cases</li>
<li><strong>Performance trade-offs</strong> between manual control and safety</li>
</ul>
<p>The same mathematical operation as before:
\[\Large \text{output}[i] = a[i] + b[i]\]</p>
<p>But with sophisticated vectorization strategies for maximum performance.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<ul>
<li>Vector size: <code>SIZE = 1024</code></li>
<li>Tile size: <code>TILE_SIZE = 32</code></li>
<li>Data type: <code>DType.float32</code></li>
<li>SIMD width: GPU-dependent</li>
<li>Layout: <code>Layout.row_major(SIZE)</code> (1D row-major)</li>
</ul>
<h2 id="1-manual-vectorization-approach"><a class="header" href="#1-manual-vectorization-approach">1. Manual vectorization approach</a></h2>
<h3 id="code-to-complete"><a class="header" href="#code-to-complete">Code to complete</a></h3>
<pre><code class="language-mojo">fn manual_vectorized_tiled_elementwise_add[
    layout: Layout,
    dtype: DType,
    simd_width: Int,
    num_threads_per_tile: Int,
    rank: Int,
    size: Int,
    tile_size: Int,
](
    output: LayoutTensor[mut=True, dtype, layout, MutableAnyOrigin],
    a: LayoutTensor[mut=False, dtype, layout, MutableAnyOrigin],
    b: LayoutTensor[mut=False, dtype, layout, MutableAnyOrigin],
    ctx: DeviceContext,
) raises:
    # Each tile contains tile_size groups of simd_width elements
    alias chunk_size = tile_size * simd_width

    @parameter
    @always_inline
    fn process_manual_vectorized_tiles[
        num_threads_per_tile: Int, rank: Int
    ](indices: IndexList[rank]) capturing -&gt; None:
        tile_id = indices[0]
        print("tile_id:", tile_id)
        out_tile = output.tile[chunk_size](tile_id)
        a_tile = a.tile[chunk_size](tile_id)
        b_tile = b.tile[chunk_size](tile_id)

        # FILL IN (7 lines at most)

    # Number of tiles needed: each tile processes chunk_size elements
    num_tiles = (size + chunk_size - 1) // chunk_size
    elementwise[
        process_manual_vectorized_tiles, num_threads_per_tile, target="gpu"
    ](num_tiles, ctx)


</code></pre>
<p><a href="https://github.com/modular/mojo-gpu-puzzles/blob/main/problems/p21/p21.mojo" class="filename">View full file: problems/p21/p21.mojo</a></p>
<details>
<summary><strong>Tips</strong></summary>
<div class="solution-tips">
<h3 id="1-understanding-chunk-organization"><a class="header" href="#1-understanding-chunk-organization">1. <strong>Understanding chunk organization</strong></a></h3>
<pre><code class="language-mojo">alias chunk_size = tile_size * simd_width  # 32 * 4 = 128 elements per chunk
</code></pre>
<p>Each tile now contains multiple SIMD groups, not just sequential elements.</p>
<h3 id="2-global-index-calculation"><a class="header" href="#2-global-index-calculation">2. <strong>Global index calculation</strong></a></h3>
<pre><code class="language-mojo">global_start = tile_id * chunk_size + i * simd_width
</code></pre>
<p>This calculates the exact global position for each SIMD vector within the chunk.</p>
<h3 id="3-direct-tensor-access"><a class="header" href="#3-direct-tensor-access">3. <strong>Direct tensor access</strong></a></h3>
<pre><code class="language-mojo">a_vec = a.load[simd_width](global_start, 0)     # Load from global tensor
output.store[simd_width](global_start, 0, ret)  # Store to global tensor
</code></pre>
<p>Note: Access the original tensors, not the tile views.</p>
<h3 id="4-key-characteristics"><a class="header" href="#4-key-characteristics">4. <strong>Key characteristics</strong></a></h3>
<ul>
<li>More control, more complexity, global tensor access</li>
<li>Perfect SIMD alignment with hardware</li>
<li>Manual bounds checking required</li>
</ul>
</div>
</details>
<h3 id="running-manual-vectorization"><a class="header" href="#running-manual-vectorization">Running manual vectorization</a></h3>
<div class="code-tabs" data-tab-group="package-manager">
  <div class="tab-buttons">
    <button class="tab-button">uv</button>
    <button class="tab-button">pixi</button>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">uv run poe p21 --manual-vectorized
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p21 --manual-vectorized
</code></pre>
  </div>
</div>
<p>Your output will look like this when not yet solved:</p>
<pre><code class="language-txt">SIZE: 1024
simd_width: 4
tile size: 32
tile_id: 0
tile_id: 1
tile_id: 2
tile_id: 3
tile_id: 4
tile_id: 5
tile_id: 6
tile_id: 7
out: HostBuffer([0.0, 0.0, 0.0, ..., 0.0, 0.0, 0.0])
expected: HostBuffer([1.0, 5.0, 9.0, ..., 4085.0, 4089.0, 4093.0])
</code></pre>
<h3 id="manual-vectorization-solution"><a class="header" href="#manual-vectorization-solution">Manual vectorization solution</a></h3>
<details class="solution-details">
<summary></summary>
<pre><code class="language-mojo">fn manual_vectorized_tiled_elementwise_add[
    layout: Layout,
    dtype: DType,
    simd_width: Int,
    num_threads_per_tile: Int,
    rank: Int,
    size: Int,
    tile_size: Int,
](
    output: LayoutTensor[mut=True, dtype, layout, MutableAnyOrigin],
    a: LayoutTensor[mut=False, dtype, layout, MutableAnyOrigin],
    b: LayoutTensor[mut=False, dtype, layout, MutableAnyOrigin],
    ctx: DeviceContext,
) raises:
    # Each tile contains tile_size groups of simd_width elements
    alias chunk_size = tile_size * simd_width

    @parameter
    @always_inline
    fn process_manual_vectorized_tiles[
        num_threads_per_tile: Int, rank: Int
    ](indices: IndexList[rank]) capturing -&gt; None:
        tile_id = indices[0]

        output_tile = output.tile[chunk_size](tile_id)
        a_tile = a.tile[chunk_size](tile_id)
        b_tile = b.tile[chunk_size](tile_id)

        @parameter
        for i in range(tile_size):
            global_start = tile_id * chunk_size + i * simd_width

            a_vec = a.load[simd_width](global_start, 0)
            b_vec = b.load[simd_width](global_start, 0)
            ret = a_vec + b_vec
            # print("tile:", tile_id, "simd_group:", i, "global_start:", global_start, "a_vec:", a_vec, "b_vec:", b_vec, "result:", ret)

            output.store[simd_width](global_start, 0, ret)

    # Number of tiles needed: each tile processes chunk_size elements
    num_tiles = (size + chunk_size - 1) // chunk_size
    elementwise[
        process_manual_vectorized_tiles, num_threads_per_tile, target="gpu"
    ](num_tiles, ctx)


</code></pre>
<div class="solution-explanation">
<h3 id="manual-vectorization-deep-dive"><a class="header" href="#manual-vectorization-deep-dive">Manual vectorization deep dive</a></h3>
<p><strong>Manual vectorization</strong> gives you direct control over SIMD operations with explicit index calculations:</p>
<ul>
<li><strong>Chunk-based organization</strong>: <code>chunk_size = tile_size * simd_width</code></li>
<li><strong>Global indexing</strong>: Direct calculation of memory positions</li>
<li><strong>Manual bounds management</strong>: You handle edge cases explicitly</li>
</ul>
<p><strong>Architecture and memory layout:</strong></p>
<pre><code class="language-mojo">alias chunk_size = tile_size * simd_width  # 32 * 4 = 128
</code></pre>
<p><strong>Chunk organization visualization (TILE_SIZE=32, SIMD_WIDTH=4):</strong></p>
<pre><code>Original array: [0, 1, 2, 3, ..., 1023]

Chunk 0 (thread 0): [0:128]    ← 128 elements = 32 SIMD groups of 4
Chunk 1 (thread 1): [128:256]  ← Next 128 elements
Chunk 2 (thread 2): [256:384]  ← Next 128 elements
...
Chunk 7 (thread 7): [896:1024] ← Final 128 elements
</code></pre>
<p><strong>Processing within one chunk:</strong></p>
<pre><code class="language-mojo">@parameter
for i in range(tile_size):  # i = 0, 1, 2, ..., 31
    global_start = tile_id * chunk_size + i * simd_width
    # For tile_id=0: global_start = 0, 4, 8, 12, ..., 124
    # For tile_id=1: global_start = 128, 132, 136, 140, ..., 252
</code></pre>
<p><strong>Performance characteristics:</strong></p>
<ul>
<li><strong>Thread count</strong>: 8 threads (1024 ÷ 128 = 8)</li>
<li><strong>Work per thread</strong>: 128 elements (32 SIMD operations of 4 elements each)</li>
<li><strong>Memory pattern</strong>: Large chunks with perfect SIMD alignment</li>
<li><strong>Overhead</strong>: Minimal - direct hardware mapping</li>
<li><strong>Safety</strong>: Manual bounds checking required</li>
</ul>
<p><strong>Key advantages:</strong></p>
<ul>
<li><strong>Predictable indexing</strong>: Exact control over memory access patterns</li>
<li><strong>Optimal alignment</strong>: SIMD operations perfectly aligned to hardware</li>
<li><strong>Maximum throughput</strong>: No overhead from safety checks</li>
<li><strong>Hardware optimization</strong>: Direct mapping to GPU SIMD units</li>
</ul>
<p><strong>Key challenges:</strong></p>
<ul>
<li><strong>Index complexity</strong>: Manual calculation of global positions</li>
<li><strong>Bounds responsibility</strong>: Must handle edge cases explicitly</li>
<li><strong>Debugging difficulty</strong>: More complex to verify correctness</li>
</ul>
</div>
</details>
<h2 id="2-mojo-vectorize-approach"><a class="header" href="#2-mojo-vectorize-approach">2. Mojo vectorize approach</a></h2>
<h3 id="code-to-complete-1"><a class="header" href="#code-to-complete-1">Code to complete</a></h3>
<pre><code class="language-mojo">fn vectorize_within_tiles_elementwise_add[
    layout: Layout,
    dtype: DType,
    simd_width: Int,
    num_threads_per_tile: Int,
    rank: Int,
    size: Int,
    tile_size: Int,
](
    output: LayoutTensor[mut=True, dtype, layout, MutableAnyOrigin],
    a: LayoutTensor[mut=False, dtype, layout, MutableAnyOrigin],
    b: LayoutTensor[mut=False, dtype, layout, MutableAnyOrigin],
    ctx: DeviceContext,
) raises:
    # Each tile contains tile_size elements (not SIMD groups)
    @parameter
    @always_inline
    fn process_tile_with_vectorize[
        num_threads_per_tile: Int, rank: Int
    ](indices: IndexList[rank]) capturing -&gt; None:
        tile_id = indices[0]
        tile_start = tile_id * tile_size
        tile_end = min(tile_start + tile_size, size)
        actual_tile_size = tile_end - tile_start
        print(
            "tile_id:",
            tile_id,
            "tile_start:",
            tile_start,
            "tile_end:",
            tile_end,
            "actual_tile_size:",
            actual_tile_size,
        )

        # FILL IN (9 lines at most)

    num_tiles = (size + tile_size - 1) // tile_size
    elementwise[
        process_tile_with_vectorize, num_threads_per_tile, target="gpu"
    ](num_tiles, ctx)


</code></pre>
<p><a href="https://github.com/modular/mojo-gpu-puzzles/blob/main/problems/p21/p21.mojo" class="filename">View full file: problems/p21/p21.mojo</a></p>
<details>
<summary><strong>Tips</strong></summary>
<div class="solution-tips">
<h3 id="1-tile-boundary-calculation"><a class="header" href="#1-tile-boundary-calculation">1. <strong>Tile boundary calculation</strong></a></h3>
<pre><code class="language-mojo">tile_start = tile_id * tile_size
tile_end = min(tile_start + tile_size, size)
actual_tile_size = tile_end - tile_start
</code></pre>
<p>Handle cases where the last tile might be smaller than <code>tile_size</code>.</p>
<h3 id="2-vectorized-function-pattern"><a class="header" href="#2-vectorized-function-pattern">2. <strong>Vectorized function pattern</strong></a></h3>
<pre><code class="language-mojo">@parameter
fn vectorized_add[width: Int](i: Int):
    global_idx = tile_start + i
    if global_idx + width &lt;= size:  # Bounds checking
        # SIMD operations here
</code></pre>
<p>The <code>width</code> parameter is automatically determined by the vectorize function.</p>
<h3 id="3-calling-vectorize"><a class="header" href="#3-calling-vectorize">3. <strong>Calling vectorize</strong></a></h3>
<pre><code class="language-mojo">vectorize[vectorized_add, simd_width](actual_tile_size)
</code></pre>
<p>This automatically handles the vectorization loop with the provided SIMD width.</p>
<h3 id="4-key-characteristics-1"><a class="header" href="#4-key-characteristics-1">4. <strong>Key characteristics</strong></a></h3>
<ul>
<li>Automatic remainder handling, built-in safety, tile-based access</li>
<li>Takes explicit SIMD width parameter</li>
<li>Built-in bounds checking and automatic remainder element processing</li>
</ul>
</div>
</details>
<h3 id="running-mojo-vectorize"><a class="header" href="#running-mojo-vectorize">Running Mojo vectorize</a></h3>
<div class="code-tabs" data-tab-group="package-manager">
  <div class="tab-buttons">
    <button class="tab-button">uv</button>
    <button class="tab-button">pixi</button>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">uv run poe p21 --vectorized
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p21 --vectorized
</code></pre>
  </div>
</div>
<p>Your output will look like this when not yet solved:</p>
<pre><code class="language-txt">SIZE: 1024
simd_width: 4
tile size: 32
tile_id: 0 tile_start: 0 tile_end: 32 actual_tile_size: 32
tile_id: 1 tile_start: 32 tile_end: 64 actual_tile_size: 32
tile_id: 2 tile_start: 64 tile_end: 96 actual_tile_size: 32
tile_id: 3 tile_start: 96 tile_end: 128 actual_tile_size: 32
...
tile_id: 29 tile_start: 928 tile_end: 960 actual_tile_size: 32
tile_id: 30 tile_start: 960 tile_end: 992 actual_tile_size: 32
tile_id: 31 tile_start: 992 tile_end: 1024 actual_tile_size: 32
out: HostBuffer([0.0, 0.0, 0.0, ..., 0.0, 0.0, 0.0])
expected: HostBuffer([1.0, 5.0, 9.0, ..., 4085.0, 4089.0, 4093.0])
</code></pre>
<h3 id="mojo-vectorize-solution"><a class="header" href="#mojo-vectorize-solution">Mojo vectorize solution</a></h3>
<details class="solution-details">
<summary></summary>
<pre><code class="language-mojo">fn vectorize_within_tiles_elementwise_add[
    layout: Layout,
    dtype: DType,
    simd_width: Int,
    num_threads_per_tile: Int,
    rank: Int,
    size: Int,
    tile_size: Int,
](
    output: LayoutTensor[mut=True, dtype, layout, MutableAnyOrigin],
    a: LayoutTensor[mut=False, dtype, layout, MutableAnyOrigin],
    b: LayoutTensor[mut=False, dtype, layout, MutableAnyOrigin],
    ctx: DeviceContext,
) raises:
    # Each tile contains tile_size elements (not SIMD groups)
    @parameter
    @always_inline
    fn process_tile_with_vectorize[
        num_threads_per_tile: Int, rank: Int
    ](indices: IndexList[rank]) capturing -&gt; None:
        tile_id = indices[0]
        tile_start = tile_id * tile_size
        tile_end = min(tile_start + tile_size, size)
        actual_tile_size = tile_end - tile_start

        @parameter
        fn vectorized_add[width: Int](i: Int):
            global_idx = tile_start + i
            if global_idx + width &lt;= size:
                a_vec = a.load[width](global_idx, 0)
                b_vec = b.load[width](global_idx, 0)
                result = a_vec + b_vec
                output.store[width](global_idx, 0, result)

        # Use vectorize within each tile
        vectorize[vectorized_add, simd_width](actual_tile_size)

    num_tiles = (size + tile_size - 1) // tile_size
    elementwise[
        process_tile_with_vectorize, num_threads_per_tile, target="gpu"
    ](num_tiles, ctx)


</code></pre>
<div class="solution-explanation">
<h3 id="mojo-vectorize-deep-dive"><a class="header" href="#mojo-vectorize-deep-dive">Mojo vectorize deep dive</a></h3>
<p><strong>Mojo’s vectorize function</strong> provides automatic vectorization with built-in safety:</p>
<ul>
<li><strong>Explicit SIMD width parameter</strong>: You provide the simd_width to use</li>
<li><strong>Built-in bounds checking</strong>: Prevents buffer overruns automatically</li>
<li><strong>Automatic remainder handling</strong>: Processes leftover elements automatically</li>
<li><strong>Nested function pattern</strong>: Clean separation of vectorization logic</li>
</ul>
<p><strong>Tile-based organization:</strong></p>
<pre><code class="language-mojo">tile_start = tile_id * tile_size    # 0, 32, 64, 96, ...
tile_end = min(tile_start + tile_size, size)
actual_tile_size = tile_end - tile_start
</code></pre>
<p><strong>Automatic vectorization mechanism:</strong></p>
<pre><code class="language-mojo">@parameter
fn vectorized_add[width: Int](i: Int):
    global_idx = tile_start + i
    if global_idx + width &lt;= size:
        # Automatic SIMD optimization
</code></pre>
<p><strong>How vectorize works:</strong></p>
<ul>
<li><strong>Automatic chunking</strong>: Divides <code>actual_tile_size</code> into chunks of your provided <code>simd_width</code></li>
<li><strong>Remainder handling</strong>: Automatically processes leftover elements with smaller widths</li>
<li><strong>Bounds safety</strong>: Automatically prevents buffer overruns</li>
<li><strong>Loop management</strong>: Handles the vectorization loop automatically</li>
</ul>
<p><strong>Execution visualization (TILE_SIZE=32, SIMD_WIDTH=4):</strong></p>
<pre><code>Tile 0 processing:
  vectorize call 0: processes elements [0:4]   with SIMD_WIDTH=4
  vectorize call 1: processes elements [4:8]   with SIMD_WIDTH=4
  ...
  vectorize call 7: processes elements [28:32] with SIMD_WIDTH=4
  Total: 8 automatic SIMD operations
</code></pre>
<p><strong>Performance characteristics:</strong></p>
<ul>
<li><strong>Thread count</strong>: 32 threads (1024 ÷ 32 = 32)</li>
<li><strong>Work per thread</strong>: 32 elements (automatic SIMD chunking)</li>
<li><strong>Memory pattern</strong>: Smaller tiles with automatic vectorization</li>
<li><strong>Overhead</strong>: Slight - automatic optimization and bounds checking</li>
<li><strong>Safety</strong>: Built-in bounds checking and edge case handling</li>
</ul>
</div>
</details>
<h2 id="performance-comparison-and-best-practices"><a class="header" href="#performance-comparison-and-best-practices">Performance comparison and best practices</a></h2>
<h3 id="when-to-use-each-approach"><a class="header" href="#when-to-use-each-approach">When to use each approach</a></h3>
<p><strong>Choose manual vectorization when:</strong></p>
<ul>
<li><strong>Maximum performance</strong> is critical</li>
<li>You have <strong>predictable, aligned data</strong> patterns</li>
<li><strong>Expert-level control</strong> over memory access is needed</li>
<li>You can <strong>guarantee bounds safety</strong> manually</li>
<li><strong>Hardware-specific optimization</strong> is required</li>
</ul>
<p><strong>Choose Mojo vectorize when:</strong></p>
<ul>
<li><strong>Development speed</strong> and safety are priorities</li>
<li>Working with <strong>irregular or dynamic data sizes</strong></li>
<li>You want <strong>automatic remainder handling</strong> instead of manual edge case management</li>
<li><strong>Bounds checking</strong> complexity would be error-prone</li>
<li>You prefer <strong>cleaner vectorization patterns</strong> over manual loop management</li>
</ul>
<h3 id="advanced-optimization-insights"><a class="header" href="#advanced-optimization-insights">Advanced optimization insights</a></h3>
<p><strong>Memory bandwidth utilization:</strong></p>
<pre><code>Manual:    8 threads × 32 SIMD ops = 256 total SIMD operations
Vectorize: 32 threads × 8 SIMD ops = 256 total SIMD operations
</code></pre>
<p>Both achieve similar total throughput but with different parallelism strategies.</p>
<p><strong>Cache behavior:</strong></p>
<ul>
<li><strong>Manual</strong>: Large chunks may exceed L1 cache, but perfect sequential access</li>
<li><strong>Vectorize</strong>: Smaller tiles fit better in cache, with automatic remainder handling</li>
</ul>
<p><strong>Hardware mapping:</strong></p>
<ul>
<li><strong>Manual</strong>: Direct control over warp utilization and SIMD unit mapping</li>
<li><strong>Vectorize</strong>: Simplified vectorization with automatic loop and remainder management</li>
</ul>
<h3 id="best-practices-summary"><a class="header" href="#best-practices-summary">Best practices summary</a></h3>
<p><strong>Manual vectorization best practices:</strong></p>
<ul>
<li>Always validate index calculations carefully</li>
<li>Use compile-time constants for <code>chunk_size</code> when possible</li>
<li>Profile memory access patterns for cache optimization</li>
<li>Consider alignment requirements for optimal SIMD performance</li>
</ul>
<p><strong>Mojo vectorize best practices:</strong></p>
<ul>
<li>Choose appropriate SIMD width for your data and hardware</li>
<li>Focus on algorithm clarity over micro-optimizations</li>
<li>Use nested parameter functions for clean vectorization logic</li>
<li>Trust automatic bounds checking and remainder handling for edge cases</li>
</ul>
<p>Both approaches represent valid strategies in the GPU performance optimization toolkit, with manual vectorization offering maximum control and Mojo’s vectorize providing safety and automatic remainder handling.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p>Now that you understand all three fundamental patterns:</p>
<ul>
<li><strong><a href="./gpu-thread-vs-simd.html">🧠 GPU Threading vs SIMD</a></strong>: Understanding the execution hierarchy</li>
<li><strong><a href="./benchmarking.html">📊 Benchmarking</a></strong>: Performance analysis and optimization</li>
</ul>
<p>💡 <strong>Key takeaway</strong>: Different vectorization strategies suit different performance requirements. Manual vectorization gives maximum control, while Mojo’s vectorize function provides safety and automatic remainder handling. Choose based on your specific performance needs and development constraints.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../puzzle_21/tile.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../puzzle_21/gpu-thread-vs-simd.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../puzzle_21/tile.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../puzzle_21/gpu-thread-vs-simd.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/mojolang.js"></script>
        <script src="../theme/sidebar.js"></script>
        <script src="../theme/solution.js"></script>
        <script src="../theme/init-amplitude.js"></script>
        <script src="../theme/tabs.js"></script>


    </div>
    </body>
</html>
