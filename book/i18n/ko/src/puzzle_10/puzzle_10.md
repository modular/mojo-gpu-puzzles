<!-- i18n-source-commit: 880bd66d68512416dd5cb724c08fa64530113525 -->

# Puzzle 10: Sanitizer로 메모리 오류와 경쟁 상태 찾기

> ⚠️ 이 퍼즐은 호환되는 **NVIDIA GPU**에서만 작동합니다. 다른 GPU 벤더 지원을 위한 도구 개발이 진행 중입니다.

## 모든 GPU 개발자가 두려워하는 순간

완벽해 보이는 GPU 코드를 작성했습니다. 알고리즘은 정확하고, 메모리 관리도 올바른 것 같고, 스레드 조율도 흠잡을 데 없어 보입니다. 자신 있게 테스트를 실행하면...

- **✅ 모든 테스트 통과**
- **✅ 성능도 훌륭함**
- **✅ 출력이 예상 결과와 일치**

뿌듯하게 코드를 프로덕션에 배포합니다. 그런데 몇 주 후, 연락이 옵니다:

- **"프로덕션에서 애플리케이션이 크래시됐어요"**
- **"실행할 때마다 결과가 달라요"**
- **"메모리 손상이 감지됐어요"**

**조용히 숨어드는 GPU 버그**의 세계에 오신 것을 환영합니다. 대규모 병렬 처리의 그늘에 숨어 있다가 가장 예상치 못한 순간에 튀어나오는 오류들이죠. 이런 버그들은 모든 테스트를 통과하고, 99%의 경우 올바른 결과를 내다가, 가장 중요한 순간에 치명적으로 실패합니다.

**중요**: 이 퍼즐은 NVIDIA GPU 하드웨어가 필요하며, `compute-sanitizer`가 NVIDIA CUDA toolkit에 포함되어 있어 `pixi`를 통해서만 사용할 수 있습니다.

## GPU 버그가 유난히 교활한 이유

CPU 프로그램에서는 버그가 보통 즉각적인 크래시나 잘못된 결과로 자신의 존재를 알립니다. 하지만 GPU 버그는 **숨기의 달인**입니다:

**조용히 데이터를 손상시키는 패턴:**

- **크래시 없는 메모리 위반**: 우연히 유효한 메모리 위치를 건드리는 범위 초과 접근
- **"대부분은 잘 동작하는" 경쟁 상태**: 타이밍에 따라 무작위처럼 나타나는 버그
- **스레드 조율 실패**: 특정 부하 조건에서만 발생하는 deadlock

**대규모 병렬 처리에서 증폭되는 문제:**

- **한 스레드의 버그가 수천 개에 영향**: 메모리 위반 하나가 전체 warp를 손상시킬 수 있음
- **경쟁 상태의 기하급수적 증가**: 스레드가 많을수록 손상 가능성도 커짐
- **하드웨어 차이가 문제를 은폐**: 같은 버그가 GPU 아키텍처마다 다르게 동작

하지만 희소식이 있습니다: **GPU 검사 도구를 익히면, 이렇게 찾기 어려운 버그들을 프로덕션에 도달하기 전에 잡아낼 수 있습니다**.

## Sanitizer 도구 모음: NVIDIA compute-sanitizer

**NVIDIA compute-sanitizer**는 GPU 버그에 맞서 싸우는 여러분의 비밀 무기입니다. 다음을 탐지할 수 있습니다:

- **메모리 위반**: 범위 초과 접근, 잘못된 포인터, 메모리 누수
- **경쟁 상태**: 스레드 간 공유 메모리 hazard
- **동기화 버그**: Deadlock, barrier 오용, 부적절한 스레드 조율
- **그 외**: `pixi run compute-sanitizer --help`로 확인

📖 **공식 문서**: [NVIDIA Compute Sanitizer User Guide](https://docs.nvidia.com/compute-sanitizer/ComputeSanitizer/index.html)

**GPU 프로그램의 X-ray**라고 생각하면 됩니다. 일반 테스트로는 볼 수 없는 숨겨진 문제까지 드러내 줍니다.

## 이 퍼즐에서 배울 내용

이 퍼즐에서는 가장 찾기 어려운 GPU 버그를 체계적으로 찾아 수정하는 방법을 배웁니다. 유능한 GPU 개발자와 뛰어난 개발자를 구분 짓는 탐정 기술을 익히게 됩니다.

### **익히게 될 핵심 기술**

1. **숨은 버그 찾기** - 테스트로는 잡히지 않는 문제 발견
2. **메모리 손상 조사** - 피해가 발생하기 전에 미정의 동작 추적
3. **경쟁 상태 탐지** - 동시성 위험 요소를 찾아내고 제거
4. **도구 선택 능력** - 상황에 맞는 sanitizer 선택
5. **프로덕션 디버깅 자신감** - 사용자에게 도달하기 전에 버그 포착

### **실전 버그 사냥 시나리오**

가장 위험한 두 종류의 GPU 버그를 조사합니다:

- **메모리 위반** - 경고 없이 데이터를 망가뜨리는 조용한 암살자
- **경쟁 상태** - 결과를 예측 불가능하게 만드는 혼돈의 씨앗

각 시나리오에서 일반 테스트로는 보이지 않는 단서를 따라가며, GPU 버그 탐정처럼 사고하는 법을 배웁니다.

## 버그 사냥 여정

이 퍼즐은 조용한 손상을 발견하는 것부터 병렬 디버깅을 배우는 것까지, 체계적으로 설계된 과정을 안내합니다:

### 👮🏼‍♂️ [메모리 위반 탐지](./memcheck.md)

**메모리 위반 조사** - 테스트는 통과해도 메모리는 거짓말을 할 때

- 테스트를 통과하면서도 메모리 범죄를 저지르는 프로그램 조사
- 미정의 동작(UB)의 징후를 알아보는 법 익히기
- `memcheck` 학습 - 메모리 위반을 잡아내는 탐지기
- GPU 하드웨어가 메모리 오류를 숨기는 이유 이해
- 체계적인 메모리 접근 검증 실습

**목표**: 방치하면 프로덕션까지 발견되지 않았을 메모리 위반 탐지 능력

### 🏁 [경쟁 상태 디버깅](./racecheck.md)

**동시성 버그 조사** - 스레드들이 서로 발목을 잡을 때

- 스레드 타이밍 때문에 무작위로 실패하는 프로그램 조사
- 데이터가 손상되기 전에 공유 메모리 위험 요소 식별법 익히기
- `racecheck` 학습 - 경쟁 상태를 잡아내는 탐지기
- 다양한 동시성 버그에 대해 `racecheck` vs `synccheck` 비교
- 스레드 동기화 전략 실습

**목표**: 고급 동시성 디버깅 - 수천 개의 병렬 스레드를 길들이는 능력

## GPU 탐정 마인드셋

GPU 검사를 하려면 **병렬 프로그램 탐정**이 되어야 합니다. 다음과 같은 사건을 조사하게 됩니다:

- **증거가 숨겨져 있다** - 직접 관찰할 수 없는 병렬 실행 속에서 버그가 발생
- **용의자가 수없이 많다** - 수천 개의 스레드 중 어떤 조합이든 범인일 수 있음
- **범행이 간헐적이다** - 경쟁 상태와 타이밍에 따른 실패
- **전문 도구가 필요하다** - 일반 디버깅으로는 볼 수 없는 것을 sanitizer가 보여줌

하지만 훌륭한 탐정처럼, 여러분도 다음을 배우게 됩니다:

- **보이지 않는 단서 따라가기** - 메모리 접근 패턴, 스레드 타이밍, 동기화 지점
- **병렬적으로 사고하기** - 수천 개의 스레드가 동시에 어떻게 상호작용하는지 고려
- **미래의 범죄 예방하기** - 개발 워크플로우에 검사 도구 통합
- **도구 믿기** - 수동 테스트로는 드러낼 수 없는 것을 sanitizer에 맡기기

## 시작하기 전에

**알아야 할 것**:

- Puzzle 1-8에서 다룬 GPU 프로그래밍 개념 (메모리 관리, 스레드 조율, barrier)
- **[호환 NVIDIA GPU 하드웨어](https://docs.modular.com/max/faq#gpu-requirements)**
- `compute-sanitizer` 접근을 위한 `pixi` 패키지 매니저 환경 설정
- **선행 퍼즐**: [Puzzle 4](../puzzle_04/introduction_layout_tensor.md)와 [Puzzle 8](../puzzle_08/layout_tensor.md) 숙지 권장

**목표**:

- 전문 GPU 개발팀에서 사용하는 **프로덕션급 디버깅 기술**
- 비용이 큰 프로덕션 장애를 예방하는 **숨은 버그 탐지 기술**
- 가장 까다로운 동시성 시나리오에서도 **병렬 디버깅 자신감**
- GPU 프로그래밍 커리어 전반에 도움이 될 **도구 전문성**
