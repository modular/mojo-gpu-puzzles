<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>📚 Mojo GPU Debugging Essentials - Mojo 🔥 GPU Puzzles</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
            rel="stylesheet">
        
        <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
        
        <link rel="stylesheet" href="../theme/css/custom.css">
        <link rel="stylesheet" href="../theme/css/highlight.css">
        <link rel="stylesheet" id="theme">
        
        <!-- Additional meta tags -->
        <meta property="og:title" content="Mojo🔥 GPU Puzzles">
        <meta property="og:description" content="Learn GPU Programming in Mojo🔥 Through Interactive Puzzles">
        <meta property="og:image" content="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">
        <meta property="og:url" content="https://puzzles.modular.com/">
        <meta name="twitter:card" content="summary">
        <meta name="twitter:image:alt" content="Mojo GPU Puzzles Logo">
        <meta name="twitter:title" content="Mojo🔥 GPU Puzzles">
        <meta name="twitter:description" content="Learn GPU Programming in Mojo🔥 Through Interactive Puzzles">
        <meta name="twitter:image" content="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">
        <link rel="icon" type="image/png" href="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/css/custom.css">
        <link rel="stylesheet" href="../theme/css/highlight.css">
        <link rel="stylesheet" href="../theme/css/tabs.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <button class="collapse-sidebar" aria-label="Collapse sidebar"></button>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Toggle color mode and talk to us buttons -->
        <script>
            document.addEventListener('click', function (event) {
                if (!event.target.matches('.theme-toggle')) return;
                event.preventDefault();
                const prevTheme = theme;
                html.classList.remove(theme);
                const newTheme = prevTheme === 'ayu' ? 'light' : 'ayu'
                html.classList.add(newTheme);
                theme = newTheme
                localStorage.setItem('mdbook-theme', theme);
            }, false);
            document.addEventListener('click', function() {
                if (!event.target.matches('.log-in')) return;
                event.preventDefault();
                window.amplitude.logEvent('LoginClickedFromPuzzles');
                window.open('https://developer.modular.com', '_blank');
            });
        </script>

        <div class="page-header">
            <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                <i class="fa fa-bars"></i>
            </label>
            <div id="menu-bar" class="menu-bar">
                <div class="left-buttons">
                    <div class="logo-section">
                        <a class="desktop-logo-link" href="https://modular.com"></a>
                        <a class="mobile-logo-link" href="https://builds.modular.com"></a>
                        <div class="slash">/</div>
                        <a class="internal-link" ref="/">Puzzles</a>
                    </div>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                    </div>
                <div class="right-buttons">
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button theme-toggle-btn" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="false" aria-expanded="false">
                        <i class="theme-toggle"></i>
                    </button>
                    <a class="menu-btn print" href="../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a class="menu-btn" href="https://github.com/modular/mojo-gpu-puzzles" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                </div>
            </div>
        </div>

        <div id="page-wrapper" class="page-wrapper">
            <div class="page">

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <div id="content" class="content">
                    <main>
                        <h1 id="-mojo-gpu-debugging-essentials"><a class="header" href="#-mojo-gpu-debugging-essentials">📚 Mojo GPU Debugging Essentials</a></h1>
<p>Welcome to the world of GPU debugging! After learning GPU programming concepts through puzzles 1-8, you’re now ready to learn the most critical skill for any GPU programmer: <strong>how to debug when things go wrong</strong>.</p>
<p>GPU debugging can seem intimidating at first - you’re dealing with thousands of threads running in parallel, different memory spaces, and hardware-specific behaviors. But with the right tools and workflow, debugging GPU code becomes systematic and manageable.</p>
<p>In this guide, you’ll learn to debug both the <strong>CPU host code</strong> (where you set up your GPU operations) and the <strong>GPU kernel code</strong> (where the parallel computation happens). We’ll use real examples, actual debugger output, and step-by-step workflows that you can immediately apply to your own projects.</p>
<p><strong>Note</strong>: The following content focuses on command-line debugging for universal IDE compatibility. If you prefer VS Code debugging, refer to the <a href="https://docs.modular.com/mojo/tools/debugging">Mojo debugging documentation</a> for VS Code-specific setup and workflows.</p>
<h2 id="why-gpu-debugging-is-different"><a class="header" href="#why-gpu-debugging-is-different">Why GPU debugging is different</a></h2>
<p>Before diving into tools, consider what makes GPU debugging unique:</p>
<ul>
<li><strong>Traditional CPU debugging</strong>: One thread, sequential execution, straightforward memory model</li>
<li><strong>GPU debugging</strong>: Thousands of threads, parallel execution, multiple memory spaces, race conditions</li>
</ul>
<p>This means you need specialized tools that can:</p>
<ul>
<li>Switch between different GPU threads</li>
<li>Inspect thread-specific variables and memory</li>
<li>Handle the complexity of parallel execution</li>
<li>Debug both CPU setup code and GPU kernel code</li>
</ul>
<h2 id="your-debugging-toolkit"><a class="header" href="#your-debugging-toolkit">Your debugging toolkit</a></h2>
<p>Mojo’s GPU debugging capabilities currently is limited to NVIDIA GPUs. The <a href="https://docs.modular.com/mojo/tools/debugging">Mojo debugging documentation</a> explains that the Mojo package includes:</p>
<ul>
<li><strong>LLDB debugger</strong> with Mojo plugin for CPU-side debugging</li>
<li><strong>CUDA-GDB integration</strong> for GPU kernel debugging</li>
<li><strong>Command-line interface</strong> via <code>mojo debug</code> for universal IDE compatibility</li>
</ul>
<p>For GPU-specific debugging, the <a href="https://docs.modular.com/mojo/tools/gpu-debugging">Mojo GPU debugging guide</a> provides additional technical details.</p>
<p>This architecture provides the best of both worlds: familiar debugging commands with GPU-specific capabilities.</p>
<h2 id="the-debugging-workflow-from-problem-to-solution"><a class="header" href="#the-debugging-workflow-from-problem-to-solution">The debugging workflow: From problem to solution</a></h2>
<p>When your GPU program crashes, produces wrong results, or behaves unexpectedly, follow this systematic approach:</p>
<ol>
<li><strong>Prepare your code for debugging</strong> (disable optimizations, add debug symbols)</li>
<li><strong>Choose the right debugger</strong> (CPU host code vs GPU kernel debugging)</li>
<li><strong>Set strategic breakpoints</strong> (where you suspect the problem lies)</li>
<li><strong>Execute and inspect</strong> (step through code, examine variables)</li>
<li><strong>Analyze patterns</strong> (memory access, thread behavior, race conditions)</li>
</ol>
<p>This workflow works whether you’re debugging a simple array operation from Puzzle 01 or complex shared memory code from Puzzle 08.</p>
<h2 id="step-1-preparing-your-code-for-debugging"><a class="header" href="#step-1-preparing-your-code-for-debugging">Step 1: Preparing your code for debugging</a></h2>
<p><strong>🥇 The golden rule</strong>: Never debug <em>optimized</em> code. Optimizations can reorder instructions, eliminate variables, and inline functions, making debugging nearly impossible.</p>
<h3 id="building-with-debug-information"><a class="header" href="#building-with-debug-information">Building with debug information</a></h3>
<p>When building Mojo programs for debugging, always include debug symbols:</p>
<pre><code class="language-bash"># Build with full debug information
mojo build -O0 -g your_program.mojo -o your_program_debug
</code></pre>
<p><strong>What these flags do:</strong></p>
<ul>
<li><code>-O0</code>: Disables all optimizations, preserving your original code structure</li>
<li><code>-g</code>: Includes debug symbols so the debugger can map machine code back to your Mojo source</li>
<li><code>-o</code>: Creates a named output file for easier identification</li>
</ul>
<h3 id="why-this-matters"><a class="header" href="#why-this-matters">Why this matters</a></h3>
<p>Without debug symbols, your debugging session looks like this:</p>
<pre><code>(lldb) print my_variable
error: use of undeclared identifier 'my_variable'
</code></pre>
<p>With debug symbols, you get:</p>
<pre><code>(lldb) print my_variable
(int) $0 = 42
</code></pre>
<h2 id="step-2-choosing-your-debugging-approach"><a class="header" href="#step-2-choosing-your-debugging-approach">Step 2: Choosing your debugging approach</a></h2>
<p>Here’s where GPU debugging gets interesting. You have <strong>four different combinations</strong> to choose from, and picking the right one saves you time:</p>
<h3 id="the-four-debugging-combinations"><a class="header" href="#the-four-debugging-combinations">The four debugging combinations</a></h3>
<p><strong>Quick reference:</strong></p>
<pre><code class="language-bash"># 1. JIT + LLDB: Debug CPU host code directly from source
pixi run mojo debug your_gpu_program.mojo

# 2. JIT + CUDA-GDB: Debug GPU kernels directly from source
pixi run mojo debug --cuda-gdb --break-on-launch your_gpu_program.mojo

# 3. Binary + LLDB: Debug CPU host code from pre-compiled binary
pixi run mojo build -O0 -g your_gpu_program.mojo -o your_program_debug
pixi run mojo debug your_program_debug

# 4. Binary + CUDA-GDB: Debug GPU kernels from pre-compiled binary
pixi run mojo debug --cuda-gdb --break-on-launch your_program_debug
</code></pre>
<h3 id="when-to-use-each-approach"><a class="header" href="#when-to-use-each-approach">When to use each approach</a></h3>
<p><strong>For learning and quick experiments:</strong></p>
<ul>
<li>Use <strong>JIT debugging</strong> - no build step required, faster iteration</li>
</ul>
<p><strong>For serious debugging sessions:</strong></p>
<ul>
<li>Use <strong>binary debugging</strong> - more predictable, cleaner debugger output</li>
</ul>
<p><strong>For CPU-side issues</strong> (buffer allocation, host memory, program logic):</p>
<ul>
<li>Use <strong>LLDB mode</strong> - perfect for debugging your <code>main()</code> function and setup code</li>
</ul>
<p><strong>For GPU kernel issues</strong> (thread behavior, GPU memory, kernel crashes):</p>
<ul>
<li>Use <strong>CUDA-GDB mode</strong> - the only way to inspect individual GPU threads</li>
</ul>
<p>The beauty is that you can mix and match. Start with JIT + LLDB to debug your setup code, then switch to JIT + CUDA-GDB to debug the actual kernel.</p>
<hr />
<h2 id="understanding-gpu-kernel-debugging-with-cuda-gdb"><a class="header" href="#understanding-gpu-kernel-debugging-with-cuda-gdb">Understanding GPU kernel debugging with CUDA-GDB</a></h2>
<p>Next comes GPU kernel debugging - the most powerful (and complex) part of your debugging toolkit.</p>
<p>When you use <code>--cuda-gdb</code>, Mojo integrates with NVIDIA’s <a href="https://docs.nvidia.com/cuda/cuda-gdb/index.html">CUDA-GDB debugger</a>. This isn’t just another debugger - it’s specifically designed for the parallel, multi-threaded world of GPU computing.</p>
<h3 id="what-makes-cuda-gdb-special"><a class="header" href="#what-makes-cuda-gdb-special">What makes CUDA-GDB special</a></h3>
<p><strong>Regular GDB</strong> debugs one thread at a time, stepping through sequential code.
<strong>CUDA-GDB</strong> debugs thousands of GPU threads simultaneously, each potentially executing different instructions.</p>
<p>This means you can:</p>
<ul>
<li><strong>Set breakpoints inside GPU kernels</strong> - pause execution when any thread hits your breakpoint</li>
<li><strong>Switch between GPU threads</strong> - examine what different threads are doing at the same moment</li>
<li><strong>Inspect thread-specific data</strong> - see how the same variable has different values across threads</li>
<li><strong>Debug memory access patterns</strong> - catch out-of-bounds access, race conditions, and memory corruption (more on detecting such issues in the Puzzle 10)</li>
<li><strong>Analyze parallel execution</strong> - understand how your threads interact and synchronize</li>
</ul>
<h3 id="connecting-to-concepts-from-previous-puzzles"><a class="header" href="#connecting-to-concepts-from-previous-puzzles">Connecting to concepts from previous puzzles</a></h3>
<p>Remember the GPU programming concepts you learned in puzzles 1-8? CUDA-GDB lets you inspect all of them at runtime:</p>
<h4 id="thread-hierarchy-debugging"><a class="header" href="#thread-hierarchy-debugging">Thread hierarchy debugging</a></h4>
<p>Back in puzzles 1-8, you wrote code like this:</p>
<pre><code class="language-mojo"># From puzzle 1: Basic thread indexing
i = thread_idx.x  # Each thread gets a unique index

# From puzzle 7: 2D thread indexing
row = thread_idx.y  # 2D grid of threads
col = thread_idx.x
</code></pre>
<p>With CUDA-GDB, you can <strong>actually see these thread coordinates in action</strong>:</p>
<pre><code class="language-gdb">(cuda-gdb) info cuda threads
</code></pre>
<p>outputs</p>
<pre><code>  BlockIdx ThreadIdx To BlockIdx To ThreadIdx Count                 PC                                                       Filename  Line
Kernel 0
*  (0,0,0)   (0,0,0)     (0,0,0)      (3,0,0)     4 0x00007fffcf26fed0 /home/ubuntu/workspace/mojo-gpu-puzzles/solutions/p01/p01.mojo    13
</code></pre>
<p>and jump to a specific thread to see what it’s doing</p>
<pre><code class="language-gdb">(cuda-gdb) cuda thread (1,0,0)
</code></pre>
<p>shows</p>
<pre><code>[Switching to CUDA thread (1,0,0)]
</code></pre>
<p>This is incredibly powerful - you can literally <strong>watch your parallel algorithm execute across different threads</strong>.</p>
<h4 id="memory-space-debugging"><a class="header" href="#memory-space-debugging">Memory space debugging</a></h4>
<p>Remember puzzle 8 where you learned about different types of GPU memory? CUDA-GDB lets you inspect all of them:</p>
<pre><code class="language-gdb"># Examine global memory (the arrays from puzzles 1-5)
(cuda-gdb) print input_array[0]@4
$1 = {{1}, {2}, {3}, {4}}   # Mojo scalar format

# Examine shared memory using local variables (thread_idx.x doesn't work)
(cuda-gdb) print shared_data[i]   # Use local variable 'i' instead
$2 = {42}
</code></pre>
<p>The debugger shows you exactly what each thread sees in memory - perfect for catching race conditions or memory access bugs.</p>
<h4 id="strategic-breakpoint-placement"><a class="header" href="#strategic-breakpoint-placement">Strategic breakpoint placement</a></h4>
<p>CUDA-GDB breakpoints are much more powerful than regular breakpoints because they work with parallel execution:</p>
<pre><code class="language-gdb"># Break when ANY thread enters your kernel
(cuda-gdb) break add_kernel

# Break only for specific threads (great for isolating issues)
(cuda-gdb) break add_kernel if thread_idx.x == 0

# Break on memory access violations
(cuda-gdb) watch input_array[thread_idx.x]

# Break on specific data conditions
(cuda-gdb) break add_kernel if input_array[thread_idx.x] &gt; 100.0
</code></pre>
<p>This lets you focus on exactly the threads and conditions you care about, instead of drowning in output from thousands of threads.</p>
<hr />
<h2 id="getting-your-environment-ready"><a class="header" href="#getting-your-environment-ready">Getting your environment ready</a></h2>
<p>Before you can start debugging, ensure your development environment is properly configured. If you’ve been working through the earlier puzzles, most of this is already set up!</p>
<p><strong>Note</strong>: Without <code>pixi</code>, you would need to manually install CUDA Toolkit from <a href="https://developer.nvidia.com/cuda-toolkit">NVIDIA’s official resources</a>, manage driver compatibility, configure environment variables, and handle version conflicts between components. <code>pixi</code> eliminates this complexity by automatically managing all CUDA dependencies, versions, and environment configuration for you.</p>
<h3 id="why-pixi-matters-for-debugging"><a class="header" href="#why-pixi-matters-for-debugging">Why <code>pixi</code> matters for debugging</a></h3>
<p><strong>The challenge</strong>: GPU debugging requires precise coordination between CUDA toolkit, GPU drivers, Mojo compiler, and debugger components. Version mismatches can lead to frustrating “debugger not found” errors.</p>
<p><strong>The solution</strong>: Using <code>pixi</code> ensures all these components work together harmoniously. When you run <code>pixi run mojo debug --cuda-gdb</code>, pixi automatically:</p>
<ul>
<li>Sets up CUDA toolkit paths</li>
<li>Loads the correct GPU drivers</li>
<li>Configures Mojo debugging plugins</li>
<li>Manages environment variables consistently</li>
</ul>
<h3 id="verifying-your-setup"><a class="header" href="#verifying-your-setup">Verifying your setup</a></h3>
<p>Let’s check that everything is working:</p>
<pre><code class="language-bash"># 1. Verify GPU hardware is accessible
pixi run nvidia-smi
# Should show your GPU(s) and driver version

# 2. Set up CUDA-GDB integration (required for GPU debugging)
pixi run setup-cuda-gdb
# Links system CUDA-GDB binaries to conda environment

# 3. Verify Mojo debugger is available
pixi run mojo debug --help
# Should show debugging options including --cuda-gdb

# 4. Test CUDA-GDB integration
pixi run cuda-gdb --version
# Should show NVIDIA CUDA-GDB version information
</code></pre>
<p>If any of these commands fail, double-check your <code>pixi.toml</code> configuration and ensure the CUDA toolkit feature is enabled.</p>
<p><strong>🚨Important</strong>: The <code>pixi run setup-cuda-gdb</code> command is required because conda’s <code>cuda-gdb</code> package only provides a wrapper script. This command links the actual CUDA-GDB binaries from your system CUDA installation (<code>/usr/local/cuda/</code>) to the conda environment, enabling full GPU debugging capabilities.</p>
<p><strong>What this command does under the hood:</strong></p>
<pre><code class="language-bash"># Creates symlinks to system CUDA-GDB binaries
ln -sf /usr/local/cuda/bin/cuda-gdb-minimal $CONDA_PREFIX/bin/cuda-gdb-minimal
ln -sf /usr/local/cuda/bin/cuda-gdb-python3.12-tui $CONDA_PREFIX/bin/cuda-gdb-python3.12-tui
</code></pre>
<hr />
<h2 id="hands-on-tutorial-your-first-gpu-debugging-session"><a class="header" href="#hands-on-tutorial-your-first-gpu-debugging-session">Hands-on tutorial: Your first GPU debugging session</a></h2>
<p>Theory is great, but nothing beats hands-on experience. Let’s debug a real program using Puzzle 01 - the simple “add 10 to each array element” kernel you know well.</p>
<p><strong>Why Puzzle 01?</strong> It’s the perfect debugging tutorial because:</p>
<ul>
<li><strong>Simple enough</strong> to understand what <em>should</em> happen</li>
<li><strong>Real GPU code</strong> with actual kernel execution</li>
<li><strong>Contains both</strong> CPU setup code and GPU kernel code</li>
<li><strong>Short execution time</strong> so you can iterate quickly</li>
</ul>
<p>By the end of this tutorial, you’ll have debugged the same program using all four debugging approaches, seen real debugger output, and learned the essential debugging commands you’ll use daily.</p>
<h3 id="learning-path-through-the-debugging-approaches"><a class="header" href="#learning-path-through-the-debugging-approaches">Learning path through the debugging approaches</a></h3>
<p>We’ll explore the <a href="#the-four-debugging-combinations">four debugging combinations</a> using Puzzle 01 as our example. <strong>Learning path</strong>: We’ll start with JIT + LLDB (easiest), then progress to CUDA-GDB (most powerful).</p>
<p><strong>⚠️ Important for GPU debugging</strong>:</p>
<ul>
<li>The <code>--break-on-launch</code> flag is <strong>required</strong> for CUDA-GDB approaches</li>
<li><strong>Pre-compiled binaries</strong> (Approaches 3 &amp; 4) preserve local variables like <code>i</code> for debugging</li>
<li><strong>JIT compilation</strong> (Approaches 1 &amp; 2) optimizes away most local variables</li>
<li>For serious GPU debugging, use <strong>Approach 4</strong> (Binary + CUDA-GDB)</li>
</ul>
<h2 id="tutorial-step-1-cpu-debugging-with-lldb"><a class="header" href="#tutorial-step-1-cpu-debugging-with-lldb">Tutorial step 1: CPU debugging with LLDB</a></h2>
<p>Let’s begin with the most common debugging scenario: <strong>your program crashes or behaves unexpectedly, and you need to see what’s happening in your <code>main()</code> function</strong>.</p>
<p><strong>The mission</strong>: Debug the CPU-side setup code in Puzzle 01 to understand how Mojo initializes GPU memory and launches kernels.</p>
<h3 id="launch-the-debugger"><a class="header" href="#launch-the-debugger">Launch the debugger</a></h3>
<p>Fire up the LLDB debugger with JIT compilation:</p>
<pre><code class="language-bash"># This compiles and debugs p01.mojo in one step
pixi run mojo debug solutions/p01/p01.mojo
</code></pre>
<p>You’ll see the LLDB prompt: <code>(lldb)</code>. You’re now inside the debugger, ready to inspect your program’s execution!</p>
<h3 id="your-first-debugging-commands"><a class="header" href="#your-first-debugging-commands">Your first debugging commands</a></h3>
<p>Let’s trace through what happens when Puzzle 01 runs. <strong>Type these commands exactly as shown</strong> and observe the output:</p>
<p><strong>Step 1: Set a breakpoint at the main function</strong></p>
<pre><code class="language-bash">(lldb) br set -n main
</code></pre>
<p>Output:</p>
<pre><code>Breakpoint 1: where = mojo`main, address = 0x00000000027d7530
</code></pre>
<p>The debugger found your main function and will pause execution there.</p>
<p><strong>Step 2: Start your program</strong></p>
<pre><code class="language-bash">(lldb) run
</code></pre>
<p>Output:</p>
<pre><code>Process 186951 launched: '/home/ubuntu/workspace/mojo-gpu-puzzles/.pixi/envs/default/bin/mojo' (x86_64)
Process 186951 stopped
* thread #1, name = 'mojo', stop reason = breakpoint 1.1
    frame #0: 0x0000555557d2b530 mojo`main
mojo`main:
-&gt;  0x555557d2b530 &lt;+0&gt;: pushq  %rbp
    0x555557d2b531 &lt;+1&gt;: movq   %rsp, %rbp
    ...
</code></pre>
<p>The program has stopped at your breakpoint. You’re currently viewing <strong>assembly code</strong>, which is normal - the debugger starts at the low-level machine code before reaching your high-level Mojo source.</p>
<p><strong>Step 3: Navigate through the startup process</strong></p>
<pre><code class="language-bash"># Try stepping through one instruction
(lldb) next
</code></pre>
<p>Output:</p>
<pre><code>Process 186951 stopped
* thread #1, name = 'mojo', stop reason = instruction step over
    frame #0: 0x0000555557d2b531 mojo`main + 1
mojo`main:
-&gt;  0x555557d2b531 &lt;+1&gt;: movq   %rsp, %rbp
    0x555557d2b534 &lt;+4&gt;: pushq  %r15
    ...
</code></pre>
<p>Stepping through assembly can be tedious. Let’s proceed to the more relevant parts.</p>
<p><strong>Step 4: Continue to reach your Mojo source code</strong></p>
<pre><code class="language-bash"># Skip through the startup assembly to get to your actual code
(lldb) continue
</code></pre>
<p>Output:</p>
<pre><code>Process 186951 resuming
Process 186951 stopped and restarted: thread 1 received signal: SIGCHLD
2 locations added to breakpoint 1
Process 186951 stopped
* thread #1, name = 'mojo', stop reason = breakpoint 1.3
    frame #0: 0x00007fff5c01e841 JIT(0x7fff5c075000)`stdlib::builtin::_startup::__mojo_main_prototype(argc=([0] = 1), argv=0x00007fffffffa858) at _startup.mojo:95:4
</code></pre>
<p>Mojo’s runtime is initializing. The <code>_startup.mojo</code> indicates Mojo’s internal startup code. The <code>SIGCHLD</code> signal is normal - it’s how Mojo manages its internal processes.</p>
<p><strong>Step 5: Continue to your actual code</strong></p>
<pre><code class="language-bash"># One more continue to reach your p01.mojo code!
(lldb) continue
</code></pre>
<p>Output:</p>
<pre><code>Process 186951 resuming
Process 186951 stopped
* thread #1, name = 'mojo', stop reason = breakpoint 1.2
    frame #0: 0x00007fff5c014040 JIT(0x7fff5c075000)`p01::main(__error__=&lt;unavailable&gt;) at p01.mojo:24:23
   21
   22
   23   def main():
-&gt; 24       with DeviceContext() as ctx:
   25           out = ctx.enqueue_create_buffer[dtype](SIZE)
   26           out = out.enqueue_fill(0)
   27           a = ctx.enqueue_create_buffer[dtype](SIZE)
</code></pre>
<p>You can now view your actual Mojo source code. Notice:</p>
<ul>
<li><strong>Line numbers 21-27</strong> from your p01.mojo file</li>
<li><strong>Current line 24</strong>: <code>with DeviceContext() as ctx:</code></li>
<li><strong>JIT compilation</strong>: The <code>JIT(0x7fff5c075000)</code> indicates Mojo compiled your code just-in-time</li>
</ul>
<p><strong>Step 6: Let the program complete</strong></p>
<pre><code class="language-bash"># Let the program run to completion
(lldb) continue
</code></pre>
<p>Output:</p>
<pre><code>Process 186951 resuming
out: HostBuffer([10.0, 11.0, 12.0, 13.0])
expected: HostBuffer([10.0, 11.0, 12.0, 13.0])
Process 186951 exited with status = 0 (0x00000000)
</code></pre>
<h3 id="what-you-just-learned"><a class="header" href="#what-you-just-learned">What you just learned</a></h3>
<p>🎓 <strong>Congratulations!</strong> You’ve just completed your first GPU program debugging session. Here’s what happened:</p>
<p><strong>The debugging journey you took:</strong></p>
<ol>
<li><strong>Started with assembly</strong> - Normal for low-level debugging, shows how the debugger works at machine level</li>
<li><strong>Navigated through Mojo startup</strong> - Learned that Mojo has internal initialization code</li>
<li><strong>Reached your source code</strong> - Saw your actual p01.mojo lines 21-27 with syntax highlighting</li>
<li><strong>Watched JIT compilation</strong> - Observed Mojo compiling your code on-the-fly</li>
<li><strong>Verified successful execution</strong> - Confirmed your program produces the expected output</li>
</ol>
<p><strong>LLDB debugging provides:</strong></p>
<ul>
<li>✅ <strong>CPU-side visibility</strong>: See your <code>main()</code> function, buffer allocation, memory setup</li>
<li>✅ <strong>Source code inspection</strong>: View your actual Mojo code with line numbers</li>
<li>✅ <strong>Variable examination</strong>: Check values of host-side variables (CPU memory)</li>
<li>✅ <strong>Program flow control</strong>: Step through your setup logic line by line</li>
<li>✅ <strong>Error investigation</strong>: Debug crashes in device setup, memory allocation, etc.</li>
</ul>
<p><strong>What LLDB cannot do:</strong></p>
<ul>
<li>❌ <strong>GPU kernel inspection</strong>: Cannot step into <code>add_10</code> function execution</li>
<li>❌ <strong>Thread-level debugging</strong>: Cannot see individual GPU thread behavior</li>
<li>❌ <strong>GPU memory access</strong>: Cannot examine data as GPU threads see it</li>
<li>❌ <strong>Parallel execution analysis</strong>: Cannot debug race conditions or synchronization</li>
</ul>
<p><strong>When to use LLDB debugging:</strong></p>
<ul>
<li>Your program crashes before the GPU code runs</li>
<li>Buffer allocation or memory setup issues</li>
<li>Understanding program initialization and flow</li>
<li>Learning how Mojo applications start up</li>
<li>Quick prototyping and experimenting with code changes</li>
</ul>
<p><strong>Key insight</strong>: LLDB is perfect for <strong>host-side debugging</strong> - everything that happens on your CPU before and after GPU execution. For the actual GPU kernel debugging, you need our next approach…</p>
<h2 id="tutorial-step-2-binary-debugging"><a class="header" href="#tutorial-step-2-binary-debugging">Tutorial step 2: Binary debugging</a></h2>
<p>You’ve learned JIT debugging - now let’s explore the <strong>professional approach</strong> used in production environments.</p>
<p><strong>The scenario</strong>: You’re debugging a complex application with multiple files, or you need to debug the same program repeatedly. Building a binary first provides more control and faster debugging iterations.</p>
<h3 id="build-your-debug-binary"><a class="header" href="#build-your-debug-binary">Build your debug binary</a></h3>
<p><strong>Step 1: Compile with debug information</strong></p>
<pre><code class="language-bash"># Create a debug build (notice the clear naming)
pixi run mojo build -O0 -g solutions/p01/p01.mojo -o solutions/p01/p01_debug
</code></pre>
<p><strong>What happens here:</strong></p>
<ul>
<li>🔧 <strong><code>-O0</code></strong>: Disables optimizations (critical for accurate debugging)</li>
<li>🔍 <strong><code>-g</code></strong>: Includes debug symbols mapping machine code to source code</li>
<li>📁 <strong><code>-o p01_debug</code></strong>: Creates a clearly named debug binary</li>
</ul>
<p><strong>Step 2: Debug the binary</strong></p>
<pre><code class="language-bash"># Debug the pre-built binary
pixi run mojo debug solutions/p01/p01_debug
</code></pre>
<h3 id="whats-different-and-better"><a class="header" href="#whats-different-and-better">What’s different (and better)</a></h3>
<p><strong>Startup comparison:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>JIT Debugging</th><th>Binary Debugging</th></tr></thead><tbody>
<tr><td>Compile + debug in one step</td><td>Build once, debug many times</td></tr>
<tr><td>Slower startup (compilation overhead)</td><td>Faster startup</td></tr>
<tr><td>Compilation messages mixed with debug output</td><td>Clean debugger output</td></tr>
<tr><td>Debug symbols generated during debugging</td><td>Fixed debug symbols</td></tr>
</tbody></table>
</div>
<p><strong>When you run the same LLDB commands</strong> (<code>br set -n main</code>, <code>run</code>, <code>continue</code>), you’ll notice:</p>
<ul>
<li><strong>Faster startup</strong> - no compilation delay</li>
<li><strong>Cleaner output</strong> - no JIT compilation messages</li>
<li><strong>More predictable</strong> - debug symbols don’t change between runs</li>
<li><strong>Professional workflow</strong> - this is how production debugging works</li>
</ul>
<hr />
<h2 id="tutorial-step-3-debugging-the-gpu-kernel"><a class="header" href="#tutorial-step-3-debugging-the-gpu-kernel">Tutorial step 3: Debugging the GPU kernel</a></h2>
<p>So far, you’ve debugged the <strong>CPU host code</strong> - the setup, memory allocation, and initialization. But what about the actual <strong>GPU kernel</strong> where the parallel computation happens?</p>
<p><strong>The challenge</strong>: Your <code>add_10</code> kernel runs on the GPU with potentially thousands of threads executing simultaneously. LLDB can’t reach into the GPU’s parallel execution environment.</p>
<p><strong>The solution</strong>: CUDA-GDB - a specialized debugger that understands GPU threads, GPU memory, and parallel execution.</p>
<h3 id="why-you-need-cuda-gdb"><a class="header" href="#why-you-need-cuda-gdb">Why you need CUDA-GDB</a></h3>
<p>Let’s understand what makes GPU debugging fundamentally different:</p>
<p><strong>CPU debugging (LLDB):</strong></p>
<ul>
<li>One thread executing sequentially</li>
<li>Single call stack to follow</li>
<li>Straightforward memory model</li>
<li>Variables have single values</li>
</ul>
<p><strong>GPU debugging (CUDA-GDB):</strong></p>
<ul>
<li>Thousands of threads executing in parallel</li>
<li>Multiple call stacks (one per thread)</li>
<li>Complex memory hierarchy (global, shared, local, registers)</li>
<li>Same variable has different values across threads</li>
</ul>
<p><strong>Real example</strong>: In your <code>add_10</code> kernel, the variable <code>thread_idx.x</code> has a <strong>different value in every thread</strong> - thread 0 sees <code>0</code>, thread 1 sees <code>1</code>, etc. Only CUDA-GDB can show you this parallel reality.</p>
<h3 id="launch-cuda-gdb-debugger"><a class="header" href="#launch-cuda-gdb-debugger">Launch CUDA-GDB debugger</a></h3>
<p><strong>Step 1: Start GPU kernel debugging</strong></p>
<p>Choose your approach:</p>
<pre><code class="language-bash"># Make sure you've run this already (once is enough)
pixi run setup-cuda-gdb

# We'll use JIT + CUDA-GDB (Approach 2 from above)
pixi run mojo debug --cuda-gdb --break-on-launch solutions/p01/p01.mojo
</code></pre>
<p>We’ll use the <strong>JIT + CUDA-GDB approach</strong> since it’s perfect for learning and quick iterations.</p>
<p><strong>Step 2: Launch and automatically stop at GPU kernel entry</strong></p>
<p>The CUDA-GDB prompt looks like: <code>(cuda-gdb)</code>. Start the program:</p>
<pre><code class="language-gdb"># Run the program - it automatically stops when the GPU kernel launches
(cuda-gdb) run
</code></pre>
<p>Output:</p>
<pre><code>Starting program: /home/ubuntu/workspace/mojo-gpu-puzzles/.pixi/envs/default/bin/mojo...
[Thread debugging using libthread_db enabled]
...
[Switching focus to CUDA kernel 0, grid 1, block (0,0,0), thread (0,0,0)]

CUDA thread hit application kernel entry function breakpoint, p01_add_10_UnsafePointer...
   &lt;&lt;&lt;(1,1,1),(4,1,1)&gt;&gt;&gt; (output=0x302000000, a=0x302000200) at p01.mojo:16
16          i = thread_idx.x
</code></pre>
<p><strong>Success! You’re automatically stopped inside the GPU kernel!</strong> The <code>--break-on-launch</code> flag caught the kernel launch and you’re now at line 16 where <code>i = thread_idx.x</code> executes.</p>
<p><strong>Important</strong>: You <strong>don’t</strong> need to manually set breakpoints like <code>break add_10</code> - the kernel entry breakpoint is automatic. GPU kernel functions have mangled names in CUDA-GDB (like <code>p01_add_10_UnsafePointer...</code>), but you’re already inside the kernel and can start debugging immediately.</p>
<p><strong>Step 3: Explore the parallel execution</strong></p>
<pre><code class="language-gdb"># See all the GPU threads that are paused at your breakpoint
(cuda-gdb) info cuda threads
</code></pre>
<p>Output:</p>
<pre><code>  BlockIdx ThreadIdx To BlockIdx To ThreadIdx Count                 PC                                                       Filename  Line
Kernel 0
*  (0,0,0)   (0,0,0)     (0,0,0)      (3,0,0)     4 0x00007fffd326fb70 /home/ubuntu/workspace/mojo-gpu-puzzles/solutions/p01/p01.mojo    16
</code></pre>
<p>Perfect! This shows you <strong>all 4 parallel GPU threads</strong> from Puzzle 01:</p>
<ul>
<li><strong><code>*</code> marks your current thread</strong>: <code>(0,0,0)</code> - the thread you’re debugging</li>
<li><strong>Thread range</strong>: From <code>(0,0,0)</code> to <code>(3,0,0)</code> - all 4 threads in the block</li>
<li><strong>Count</strong>: <code>4</code> - matches <code>THREADS_PER_BLOCK = 4</code> from the code</li>
<li><strong>Same location</strong>: All threads are paused at line 16 in <code>p01.mojo</code></li>
</ul>
<p><strong>Step 4: Step through the kernel and examine variables</strong></p>
<pre><code class="language-gdb"># Use 'next' to step through code (not 'step' which goes into internals)
(cuda-gdb) next
</code></pre>
<p>Output:</p>
<pre><code>p01_add_10_UnsafePointer... at p01.mojo:17
17          output[i] = a[i] + 10.0
</code></pre>
<pre><code class="language-gdb"># Local variables work with pre-compiled binaries!
(cuda-gdb) print i
</code></pre>
<p>Output:</p>
<pre><code>$1 = 0                    # This thread's index (captures thread_idx.x value)
</code></pre>
<pre><code class="language-gdb"># GPU built-ins don't work, but you don't need them
(cuda-gdb) print thread_idx.x
</code></pre>
<p>Output:</p>
<pre><code>No symbol "thread_idx" in current context.
</code></pre>
<pre><code class="language-gdb"># Access thread-specific data using local variables
(cuda-gdb) print a[i]     # This thread's input: a[0]
</code></pre>
<p>Output:</p>
<pre><code>$2 = {0}                  # Input value (Mojo scalar format)
</code></pre>
<pre><code class="language-gdb">(cuda-gdb) print output[i] # This thread's output BEFORE computation
</code></pre>
<p>Output:</p>
<pre><code>$3 = {0}                  # Still zero - computation hasn't executed yet!
</code></pre>
<pre><code class="language-gdb"># Execute the computation line
(cuda-gdb) next
</code></pre>
<p>Output:</p>
<pre><code>13      fn add_10(         # Steps to function signature line after computation
</code></pre>
<pre><code class="language-gdb"># Now check the result
(cuda-gdb) print output[i]
</code></pre>
<p>Output:</p>
<pre><code>$4 = {10}                 # Now shows the computed result: 0 + 10 = 10
</code></pre>
<pre><code class="language-gdb"># Function parameters are still available
(cuda-gdb) print a
</code></pre>
<p>Output:</p>
<pre><code>$5 = (!pop.scalar&lt;f32&gt; * @register) 0x302000200
</code></pre>
<p><strong>Step 5: Navigate between parallel threads</strong></p>
<pre><code class="language-gdb"># Switch to a different thread to see its execution
(cuda-gdb) cuda thread (1,0,0)
</code></pre>
<p>Output:</p>
<pre><code>[Switching focus to CUDA kernel 0, grid 1, block (0,0,0), thread (1,0,0), device 0, sm 0, warp 0, lane 1]
13      fn add_10(         # Thread 1 is also at function signature
</code></pre>
<pre><code class="language-gdb"># Check the thread's local variable
(cuda-gdb) print i
</code></pre>
<p>Output:</p>
<pre><code>$5 = 1                    # Thread 1's index (different from Thread 0!)
</code></pre>
<pre><code class="language-gdb"># Examine what this thread processes
(cuda-gdb) print a[i]     # This thread's input: a[1]
</code></pre>
<p>Output:</p>
<pre><code>$6 = {1}                  # Input value for thread 1
</code></pre>
<pre><code class="language-gdb"># Thread 1's computation is already done (parallel execution!)
(cuda-gdb) print output[i] # This thread's output: output[1]
</code></pre>
<p>Output:</p>
<pre><code>$7 = {11}                 # 1 + 10 = 11 (already computed)
</code></pre>
<pre><code class="language-gdb"># BEST TECHNIQUE: View all thread results at once
(cuda-gdb) print output[0]@4
</code></pre>
<p>Output:</p>
<pre><code>$8 = {{10}, {11}, {12}, {13}}     # All 4 threads' results in one command!
</code></pre>
<pre><code class="language-gdb">(cuda-gdb) print a[0]@4
</code></pre>
<p>Output:</p>
<pre><code>$9 = {{0}, {1}, {2}, {3}}         # All input values for comparison
</code></pre>
<pre><code class="language-gdb"># Don't step too far or you'll lose CUDA context
(cuda-gdb) next
</code></pre>
<p>Output:</p>
<pre><code>[Switching to Thread 0x7ffff7e25840 (LWP 306942)]  # Back to host thread
0x00007fffeca3f831 in ?? () from /lib/x86_64-linux-gnu/libcuda.so.1
</code></pre>
<pre><code class="language-gdb">(cuda-gdb) print output[i]
</code></pre>
<p>Output:</p>
<pre><code>No symbol "output" in current context.  # Lost GPU context!
</code></pre>
<p><strong>Key insights from this debugging session:</strong></p>
<ul>
<li>🤯 <strong>Parallel execution is real</strong> - when you switch to thread (1,0,0), its computation is already done!</li>
<li><strong>Each thread has different data</strong> - <code>i=0</code> vs <code>i=1</code>, <code>a[i]={0}</code> vs <code>a[i]={1}</code>, <code>output[i]={10}</code> vs <code>output[i]={11}</code></li>
<li><strong>Array inspection is powerful</strong> - <code>print output[0]@4</code> shows all threads’ results: <code>{{10}, {11}, {12}, {13}}</code></li>
<li><strong>GPU context is fragile</strong> - stepping too far switches back to host thread and loses GPU variables</li>
</ul>
<p>This demonstrates the fundamental nature of parallel computing: <strong>same code, different data per thread, executing simultaneously.</strong></p>
<h3 id="what-youve-learned-with-cuda-gdb"><a class="header" href="#what-youve-learned-with-cuda-gdb">What you’ve learned with CUDA-GDB</a></h3>
<p>You’ve completed GPU kernel execution debugging with <strong>pre-compiled binaries</strong>. Here’s what actually works:</p>
<p><strong>GPU debugging capabilities you gained:</strong></p>
<ul>
<li>✅ <strong>Debug GPU kernels automatically</strong> - <code>--break-on-launch</code> stops at kernel entry</li>
<li>✅ <strong>Navigate between GPU threads</strong> - switch contexts with <code>cuda thread</code></li>
<li>✅ <strong>Access local variables</strong> - <code>print i</code> works with <code>-O0 -g</code> compiled binaries</li>
<li>✅ <strong>Inspect thread-specific data</strong> - each thread shows different <code>i</code>, <code>a[i]</code>, <code>output[i]</code> values</li>
<li>✅ <strong>View all thread results</strong> - <code>print output[0]@4</code> shows <code>{{10}, {11}, {12}, {13}}</code> in one command</li>
<li>✅ <strong>Step through GPU code</strong> - <code>next</code> executes computation and shows results</li>
<li>✅ <strong>See parallel execution</strong> - threads execute simultaneously (other threads already computed when you switch)</li>
<li>✅ <strong>Access function parameters</strong> - examine <code>output</code> and <code>a</code> pointers</li>
<li>❌ <strong>GPU built-ins unavailable</strong> - <code>thread_idx.x</code>, <code>blockIdx.x</code> etc. don’t work (but local variables do!)</li>
<li>📊 <strong>Mojo scalar format</strong> - values display as <code>{10}</code> instead of <code>10.0</code></li>
<li>⚠️ <strong>Fragile GPU context</strong> - stepping too far loses access to GPU variables</li>
</ul>
<p><strong>Key insights</strong>:</p>
<ul>
<li><strong>Pre-compiled binaries</strong> (<code>mojo build -O0 -g</code>) are essential - local variables preserved</li>
<li><strong>Array inspection with <code>@N</code></strong> - most efficient way to see all parallel results at once</li>
<li><strong>GPU built-ins are missing</strong> - but local variables like <code>i</code> capture what you need</li>
<li><strong>Mojo uses <code>{value}</code> format</strong> - scalars display as <code>{10}</code> instead of <code>10.0</code></li>
<li><strong>Be careful with stepping</strong> - easy to lose GPU context and return to host thread</li>
</ul>
<p><strong>Real-world debugging techniques</strong></p>
<p>Now let’s explore practical debugging scenarios you’ll encounter in real GPU programming:</p>
<h4 id="technique-1-verifying-thread-boundaries"><a class="header" href="#technique-1-verifying-thread-boundaries">Technique 1: Verifying thread boundaries</a></h4>
<pre><code class="language-gdb"># Check if all 4 threads computed correctly
(cuda-gdb) print output[0]@4
</code></pre>
<p>Output:</p>
<pre><code>$8 = {{10}, {11}, {12}, {13}}    # All 4 threads computed correctly
</code></pre>
<pre><code class="language-gdb"># Check beyond valid range to detect out-of-bounds issues
(cuda-gdb) print output[0]@5
</code></pre>
<p>Output:</p>
<pre><code>$9 = {{10}, {11}, {12}, {13}, {0}}  # Element 4 is uninitialized (good!)
</code></pre>
<pre><code class="language-gdb"># Compare with input to verify computation
(cuda-gdb) print a[0]@4
</code></pre>
<p>Output:</p>
<pre><code>$10 = {{0}, {1}, {2}, {3}}       # Input values: 0+10=10, 1+10=11, etc.
</code></pre>
<p><strong>Why this matters</strong>: Out-of-bounds access is the #1 cause of GPU crashes. These debugging steps catch it early.</p>
<h4 id="technique-2-understanding-thread-organization"><a class="header" href="#technique-2-understanding-thread-organization">Technique 2: Understanding thread organization</a></h4>
<pre><code class="language-gdb"># See how your threads are organized into blocks
(cuda-gdb) info cuda blocks
</code></pre>
<p>Output:</p>
<pre><code>  BlockIdx To BlockIdx Count   State
Kernel 0
*  (0,0,0)     (0,0,0)     1 running
</code></pre>
<pre><code class="language-gdb"># See all threads in the current block
(cuda-gdb) info cuda threads
</code></pre>
<p>Output shows which threads are active, stopped, or have errors.</p>
<p><strong>Why this matters</strong>: Understanding thread block organization helps debug synchronization and shared memory issues.</p>
<h4 id="technique-3-memory-access-pattern-analysis"><a class="header" href="#technique-3-memory-access-pattern-analysis">Technique 3: Memory access pattern analysis</a></h4>
<pre><code class="language-gdb"># Check GPU memory addresses:
(cuda-gdb) print a               # Input array GPU pointer
</code></pre>
<p>Output:</p>
<pre><code>$9 = (!pop.scalar&lt;f32&gt; * @register) 0x302000200
</code></pre>
<pre><code class="language-gdb">(cuda-gdb) print output          # Output array GPU pointer
</code></pre>
<p>Output:</p>
<pre><code>$10 = (!pop.scalar&lt;f32&gt; * @register) 0x302000000
</code></pre>
<pre><code class="language-gdb"># Verify memory access pattern using local variables:
(cuda-gdb) print a[i]            # Each thread accesses its own element using 'i'
</code></pre>
<p>Output:</p>
<pre><code>$11 = {0}                        # Thread's input data
</code></pre>
<p><strong>Why this matters</strong>: Memory access patterns affect performance and correctness. Wrong patterns cause race conditions or crashes.</p>
<h4 id="technique-4-results-verification-and-completion"><a class="header" href="#technique-4-results-verification-and-completion">Technique 4: Results verification and completion</a></h4>
<pre><code class="language-gdb"># After stepping through kernel execution, verify the final results
(cuda-gdb) print output[0]@4
</code></pre>
<p>Output:</p>
<pre><code>$11 = {10.0, 11.0, 12.0, 13.0}    # Perfect! Each element increased by 10
</code></pre>
<pre><code class="language-gdb"># Let the program complete normally
(cuda-gdb) continue
</code></pre>
<p>Output:</p>
<pre><code>...Program output shows success...
</code></pre>
<pre><code class="language-gdb"># Exit the debugger
(cuda-gdb) exit
</code></pre>
<p>You’ve completed debugging a GPU kernel execution from setup to results.</p>
<h2 id="your-gpu-debugging-progress-key-insights"><a class="header" href="#your-gpu-debugging-progress-key-insights">Your GPU debugging progress: key insights</a></h2>
<p>You’ve completed a comprehensive GPU debugging tutorial. Here’s what you discovered about parallel computing:</p>
<h3 id="deep-insights-about-parallel-execution"><a class="header" href="#deep-insights-about-parallel-execution">Deep insights about parallel execution</a></h3>
<ol>
<li>
<p><strong>Thread indexing in action</strong>: You <strong>saw</strong> <code>thread_idx.x</code> have different values (0, 1, 2, 3…) across parallel threads - not just read about it in theory</p>
</li>
<li>
<p><strong>Memory access patterns revealed</strong>: Each thread accesses <code>a[thread_idx.x]</code> and writes to <code>output[thread_idx.x]</code>, creating perfect data parallelism with no conflicts</p>
</li>
<li>
<p><strong>Parallel execution demystified</strong>: Thousands of threads executing the <strong>same kernel code</strong> simultaneously, but each processing <strong>different data elements</strong></p>
</li>
<li>
<p><strong>GPU memory hierarchy</strong>: Arrays live in global GPU memory, accessible by all threads but with thread-specific indexing</p>
</li>
</ol>
<h3 id="debugging-techniques-that-transfer-to-all-puzzles"><a class="header" href="#debugging-techniques-that-transfer-to-all-puzzles">Debugging techniques that transfer to all puzzles</a></h3>
<p><strong>From Puzzle 01 to Puzzle 08 and beyond</strong>, you now have techniques that work universally:</p>
<ul>
<li><strong>Start with LLDB</strong> for CPU-side issues (device setup, memory allocation)</li>
<li><strong>Switch to CUDA-GDB</strong> for GPU kernel issues (thread behavior, memory access)</li>
<li><strong>Use conditional breakpoints</strong> to focus on specific threads or data conditions</li>
<li><strong>Navigate between threads</strong> to understand parallel execution patterns</li>
<li><strong>Verify memory access patterns</strong> to catch race conditions and out-of-bounds errors</li>
</ul>
<p><strong>Scalability</strong>: These same techniques work whether you’re debugging:</p>
<ul>
<li><strong>Puzzle 01</strong>: 4-element arrays with simple addition</li>
<li><strong>Puzzle 08</strong>: Complex shared memory operations with thread synchronization</li>
<li><strong>Production code</strong>: Million-element arrays with sophisticated algorithms</li>
</ul>
<hr />
<h2 id="essential-debugging-commands-reference"><a class="header" href="#essential-debugging-commands-reference">Essential debugging commands reference</a></h2>
<p>Now that you’ve learned the debugging workflow, here’s your <strong>quick reference guide</strong> for daily debugging sessions. Bookmark this section!</p>
<h3 id="gdb-command-abbreviations-save-time"><a class="header" href="#gdb-command-abbreviations-save-time">GDB command abbreviations (save time!)</a></h3>
<p><strong>Most commonly used shortcuts</strong> for faster debugging:</p>
<div class="table-wrapper"><table><thead><tr><th>Abbreviation</th><th>Full Command</th><th>Function</th></tr></thead><tbody>
<tr><td><code>r</code></td><td><code>run</code></td><td>Start/launch the program</td></tr>
<tr><td><code>c</code></td><td><code>continue</code></td><td>Resume execution</td></tr>
<tr><td><code>n</code></td><td><code>next</code></td><td>Step over (same level)</td></tr>
<tr><td><code>s</code></td><td><code>step</code></td><td>Step into functions</td></tr>
<tr><td><code>b</code></td><td><code>break</code></td><td>Set breakpoint</td></tr>
<tr><td><code>p</code></td><td><code>print</code></td><td>Print variable value</td></tr>
<tr><td><code>l</code></td><td><code>list</code></td><td>Show source code</td></tr>
<tr><td><code>q</code></td><td><code>quit</code></td><td>Exit debugger</td></tr>
</tbody></table>
</div>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">(cuda-gdb) r                    # Instead of 'run'
(cuda-gdb) b 39                 # Instead of 'break 39'
(cuda-gdb) p thread_id          # Instead of 'print thread_id'
(cuda-gdb) n                    # Instead of 'next'
(cuda-gdb) c                    # Instead of 'continue'
</code></pre>
<p><strong>⚡ Pro tip</strong>: Use abbreviations for 3-5x faster debugging sessions!</p>
<h2 id="lldb-commands-cpu-host-code-debugging"><a class="header" href="#lldb-commands-cpu-host-code-debugging">LLDB commands (CPU host code debugging)</a></h2>
<p><strong>When to use</strong>: Debugging device setup, memory allocation, program flow, host-side crashes</p>
<h3 id="execution-control"><a class="header" href="#execution-control">Execution control</a></h3>
<pre><code class="language-bash">(lldb) run                    # Launch your program
(lldb) continue              # Resume execution (alias: c)
(lldb) step                  # Step into functions (source level)
(lldb) next                  # Step over functions (source level)
(lldb) finish                # Step out of current function
</code></pre>
<h3 id="breakpoint-management"><a class="header" href="#breakpoint-management">Breakpoint management</a></h3>
<pre><code class="language-bash">(lldb) br set -n main        # Set breakpoint at main function
(lldb) br set -n function_name     # Set breakpoint at any function
(lldb) br list               # Show all breakpoints
(lldb) br delete 1           # Delete breakpoint #1
(lldb) br disable 1          # Temporarily disable breakpoint #1
</code></pre>
<h3 id="variable-inspection"><a class="header" href="#variable-inspection">Variable inspection</a></h3>
<pre><code class="language-bash">(lldb) print variable_name   # Show variable value
(lldb) print pointer[offset]        # Dereference pointer
(lldb) print array[0]@4      # Show first 4 array elements
</code></pre>
<h2 id="cuda-gdb-commands-gpu-kernel-debugging"><a class="header" href="#cuda-gdb-commands-gpu-kernel-debugging">CUDA-GDB commands (GPU kernel debugging)</a></h2>
<p><strong>When to use</strong>: Debugging GPU kernels, thread behavior, parallel execution, GPU memory issues</p>
<h3 id="gpu-state-inspection"><a class="header" href="#gpu-state-inspection">GPU state inspection</a></h3>
<pre><code class="language-bash">(cuda-gdb) info cuda threads    # Show all GPU threads and their state
(cuda-gdb) info cuda blocks     # Show all thread blocks
(cuda-gdb) cuda kernel          # List active GPU kernels
</code></pre>
<h3 id="thread-navigation-the-most-powerful-feature"><a class="header" href="#thread-navigation-the-most-powerful-feature">Thread navigation (The most powerful feature!)</a></h3>
<pre><code class="language-bash">(cuda-gdb) cuda thread (0,0,0)  # Switch to specific thread coordinates
(cuda-gdb) cuda block (0,0)     # Switch to specific block
(cuda-gdb) cuda thread          # Show current thread coordinates
</code></pre>
<h3 id="thread-specific-variable-inspection"><a class="header" href="#thread-specific-variable-inspection">Thread-specific variable inspection</a></h3>
<pre><code class="language-bash"># Local variables and function parameters:
(cuda-gdb) print i              # Local thread index variable
(cuda-gdb) print output         # Function parameter pointers
(cuda-gdb) print a              # Function parameter pointers
</code></pre>
<h3 id="gpu-memory-access"><a class="header" href="#gpu-memory-access">GPU memory access</a></h3>
<pre><code class="language-bash"># Array inspection using local variables (what actually works):
(cuda-gdb) print array[i]       # Thread-specific array access using local variable
(cuda-gdb) print array[0]@4     # View multiple elements: {{val1}, {val2}, {val3}, {val4}}
</code></pre>
<h3 id="advanced-gpu-debugging"><a class="header" href="#advanced-gpu-debugging">Advanced GPU debugging</a></h3>
<pre><code class="language-bash"># Memory watching
(cuda-gdb) watch array[i]     # Break on memory changes
(cuda-gdb) rwatch array[i]    # Break on memory reads
</code></pre>
<hr />
<h2 id="quick-reference-debugging-decision-tree"><a class="header" href="#quick-reference-debugging-decision-tree">Quick reference: Debugging decision tree</a></h2>
<p><strong>🤔 What type of issue are you debugging?</strong></p>
<h3 id="program-crashes-before-gpu-code-runs"><a class="header" href="#program-crashes-before-gpu-code-runs">Program crashes before GPU code runs</a></h3>
<p>→ <strong>Use LLDB debugging</strong></p>
<pre><code class="language-bash">pixi run mojo debug your_program.mojo
</code></pre>
<h3 id="gpu-kernel-produces-wrong-results"><a class="header" href="#gpu-kernel-produces-wrong-results">GPU kernel produces wrong results</a></h3>
<p>→ <strong>Use CUDA-GDB with conditional breakpoints</strong></p>
<pre><code class="language-bash">pixi run mojo debug --cuda-gdb --break-on-launch your_program.mojo
</code></pre>
<h3 id="performance-issues-or-race-conditions"><a class="header" href="#performance-issues-or-race-conditions">Performance issues or race conditions</a></h3>
<p>→ <strong>Use binary debugging for repeatability</strong></p>
<pre><code class="language-bash">pixi run mojo build -O0 -g your_program.mojo -o debug_binary
pixi run mojo debug --cuda-gdb --break-on-launch debug_binary
</code></pre>
<hr />
<h2 id="youve-learned-the-essentials-of-gpu-debugging"><a class="header" href="#youve-learned-the-essentials-of-gpu-debugging">You’ve learned the essentials of GPU debugging</a></h2>
<p>You’ve completed a comprehensive tutorial on GPU debugging fundamentals. Here’s what you’ve accomplished:</p>
<h3 id="skills-youve-learned"><a class="header" href="#skills-youve-learned">Skills you’ve learned</a></h3>
<p><strong>Multi-level debugging knowledge</strong>:</p>
<ul>
<li>✅ <strong>CPU host debugging</strong> with LLDB - debug device setup, memory allocation, program flow</li>
<li>✅ <strong>GPU kernel debugging</strong> with CUDA-GDB - debug parallel threads, GPU memory, race conditions</li>
<li>✅ <strong>JIT vs binary debugging</strong> - choose the right approach for different scenarios</li>
<li>✅ <strong>Environment management</strong> with pixi - ensure consistent, reliable debugging setups</li>
</ul>
<p><strong>Real parallel programming insights</strong>:</p>
<ul>
<li><strong>Saw threads in action</strong> - witnessed <code>thread_idx.x</code> having different values across parallel threads</li>
<li><strong>Understood memory hierarchy</strong> - debugged global GPU memory, shared memory, thread-local variables</li>
<li><strong>Learned thread navigation</strong> - jumped between thousands of parallel threads efficiently</li>
</ul>
<h3 id="from-theory-to-practice"><a class="header" href="#from-theory-to-practice">From theory to practice</a></h3>
<p>You didn’t just read about GPU debugging - you <strong>experienced it</strong>:</p>
<ul>
<li><strong>Debugged real code</strong>: Puzzle 01’s <code>add_10</code> kernel with actual GPU execution</li>
<li><strong>Saw real debugger output</strong>: LLDB assembly, CUDA-GDB thread states, memory addresses</li>
<li><strong>Used professional tools</strong>: The same CUDA-GDB used in production GPU development</li>
<li><strong>Solved real scenarios</strong>: Out-of-bounds access, race conditions, kernel launch failures</li>
</ul>
<h3 id="your-debugging-toolkit-1"><a class="header" href="#your-debugging-toolkit-1">Your debugging toolkit</a></h3>
<p><strong>Quick decision guide</strong> (keep this handy!):</p>
<div class="table-wrapper"><table><thead><tr><th>Problem Type</th><th>Tool</th><th>Command</th></tr></thead><tbody>
<tr><td><strong>Program crashes before GPU</strong></td><td>LLDB</td><td><code>pixi run mojo debug program.mojo</code></td></tr>
<tr><td><strong>GPU kernel issues</strong></td><td>CUDA-GDB</td><td><code>pixi run mojo debug --cuda-gdb --break-on-launch program.mojo</code></td></tr>
<tr><td><strong>Race conditions</strong></td><td>CUDA-GDB + thread nav</td><td><code>(cuda-gdb) cuda thread (0,0,0)</code></td></tr>
</tbody></table>
</div>
<p><strong>Essential commands</strong> (for daily debugging):</p>
<pre><code class="language-bash"># GPU thread inspection
(cuda-gdb) info cuda threads          # See all threads
(cuda-gdb) cuda thread (0,0,0)        # Switch threads
(cuda-gdb) print i                    # Local thread index (thread_idx.x equivalent)

# Smart breakpoints (using local variables since GPU built-ins don't work)
(cuda-gdb) break kernel if i == 0      # Focus on thread 0
(cuda-gdb) break kernel if array[i] &gt; 100  # Focus on data conditions

# Memory debugging
(cuda-gdb) print array[i]              # Thread-specific data using local variable
(cuda-gdb) print array[0]@4            # Array segments: {{val1}, {val2}, {val3}, {val4}}
</code></pre>
<hr />
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>GPU debugging involves thousands of parallel threads, complex memory hierarchies, and specialized tools. You now have:</p>
<ul>
<li><strong>Systematic workflows</strong> that work for any GPU program</li>
<li><strong>Professional tools</strong> familiarity with LLDB and CUDA-GDB</li>
<li><strong>Real experience</strong> debugging actual parallel code</li>
<li><strong>Practical strategies</strong> for handling complex scenarios</li>
<li><strong>Foundation</strong> to tackle GPU debugging challenges</li>
</ul>
<hr />
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional resources</a></h2>
<ul>
<li><a href="https://docs.modular.com/mojo/tools/debugging">Mojo Debugging Documentation</a></li>
<li><a href="https://docs.modular.com/mojo/tools/gpu-debugging">Mojo GPU Debugging Guide</a></li>
<li><a href="https://docs.nvidia.com/cuda/cuda-gdb/index.html">NVIDIA CUDA-GDB User Guide</a></li>
<li><a href="https://docs.nvidia.com/cuda/cuda-gdb/index.html#command-reference">CUDA-GDB Command Reference</a></li>
</ul>
<p><strong>Note</strong>: GPU debugging requires patience and systematic investigation. The workflow and commands in this puzzle provide the foundation for debugging complex GPU issues you’ll encounter in real applications.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../puzzle_09/puzzle_09.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../puzzle_09/first_case.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../puzzle_09/puzzle_09.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../puzzle_09/first_case.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/mojolang.js"></script>
        <script src="../theme/sidebar.js"></script>
        <script src="../theme/solution.js"></script>
        <script src="../theme/init-amplitude.js"></script>
        <script src="../theme/tabs.js"></script>


    </div>
    </body>
</html>
