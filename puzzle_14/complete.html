<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>‚≠ê Complete Version - Mojo üî• GPU Puzzles</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
            rel="stylesheet">
        
        <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
        
        <link rel="stylesheet" href="../theme/css/custom.css">
        <link rel="stylesheet" href="../theme/css/highlight.css">
        <link rel="stylesheet" id="theme">
        
        <!-- Additional meta tags -->
        <meta property="og:title" content="Mojoüî• GPU Puzzles">
        <meta property="og:description" content="Learn GPU Programming in Mojoüî• Through Interactive Puzzles">
        <meta property="og:image" content="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">
        <meta property="og:url" content="https://puzzles.modular.com/">
        <meta name="twitter:card" content="summary">
        <meta name="twitter:image:alt" content="Mojo GPU Puzzles Logo">
        <meta name="twitter:title" content="Mojoüî• GPU Puzzles">
        <meta name="twitter:description" content="Learn GPU Programming in Mojoüî• Through Interactive Puzzles">
        <meta name="twitter:image" content="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">
        <link rel="icon" type="image/png" href="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/css/custom.css">
        <link rel="stylesheet" href="../theme/css/highlight.css">
        <link rel="stylesheet" href="../theme/css/tabs.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <button class="collapse-sidebar" aria-label="Collapse sidebar"></button>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Toggle color mode and talk to us buttons -->
        <script>
            document.addEventListener('click', function (event) {
                if (!event.target.matches('.theme-toggle')) return;
                event.preventDefault();
                const prevTheme = theme;
                html.classList.remove(theme);
                const newTheme = prevTheme === 'ayu' ? 'light' : 'ayu'
                html.classList.add(newTheme);
                theme = newTheme
                localStorage.setItem('mdbook-theme', theme);
            }, false);
            document.addEventListener('click', function() {
                if (!event.target.matches('.log-in')) return;
                event.preventDefault();
                window.amplitude.logEvent('LoginClickedFromPuzzles');
                window.open('https://developer.modular.com', '_blank');
            });
        </script>

        <div class="page-header">
            <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                <i class="fa fa-bars"></i>
            </label>
            <div id="menu-bar" class="menu-bar">
                <div class="left-buttons">
                    <div class="logo-section">
                        <a class="desktop-logo-link" href="https://modular.com"></a>
                        <a class="mobile-logo-link" href="https://builds.modular.com"></a>
                        <div class="slash">/</div>
                        <a class="internal-link" ref="/">Puzzles</a>
                    </div>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                    </div>
                <div class="right-buttons">
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button theme-toggle-btn" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="false" aria-expanded="false">
                        <i class="theme-toggle"></i>
                    </button>
                    <a class="menu-btn print" href="../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a class="menu-btn" href="https://github.com/modular/mojo-gpu-puzzles" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                </div>
            </div>
        </div>

        <div id="page-wrapper" class="page-wrapper">
            <div class="page">

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <div id="content" class="content">
                    <main>
                        <h1 id="complete-version"><a class="header" href="#complete-version">Complete Version</a></h1>
<p>Implement a kernel that computes a prefix-sum over 1D LayoutTensor <code>a</code> and stores it in 1D LayoutTensor <code>output</code>.</p>
<p><strong>Note:</strong> <em>If the size of <code>a</code> is greater than the block size, we need to synchronize across multiple blocks to get the correct result.</em></p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<ul>
<li>Array size: <code>SIZE_2 = 15</code> elements</li>
<li>Threads per block: <code>TPB = 8</code></li>
<li>Number of blocks: 2</li>
<li>Shared memory: <code>TPB</code> elements per block</li>
</ul>
<p>Notes:</p>
<ul>
<li><strong>Multiple blocks</strong>: When the input array is larger than one block, we need a multi-phase approach</li>
<li><strong>Block-level sync</strong>: Within a block, use <code>barrier()</code> to synchronize threads</li>
<li><strong>Host-level sync</strong>: Between blocks, use <code>ctx.synchronize()</code> at the host level</li>
<li><strong>Auxiliary storage</strong>: Use extra space to store block sums for cross-block communication</li>
</ul>
<h2 id="code-to-complete"><a class="header" href="#code-to-complete">Code to complete</a></h2>
<p>You need to complete two separate kernel functions for the multi-block prefix sum:</p>
<ol>
<li><strong>First kernel</strong> (<code>prefix_sum_local_phase</code>): Computes local prefix sums within each block and stores block sums</li>
<li><strong>Second kernel</strong> (<code>prefix_sum_block_sum_phase</code>): Adds previous block sums to elements in subsequent blocks</li>
</ol>
<p>The main function will handle the necessary host-side synchronization between these kernels.</p>
<pre><code class="language-mojo">alias SIZE_2 = 15
alias BLOCKS_PER_GRID_2 = (2, 1)
alias THREADS_PER_BLOCK_2 = (TPB, 1)
alias EXTENDED_SIZE = SIZE_2 + 2  # up to 2 blocks
alias extended_layout = Layout.row_major(EXTENDED_SIZE)


# Kernel 1: Compute local prefix sums and store block sums in out
fn prefix_sum_local_phase[
    out_layout: Layout, in_layout: Layout
](
    output: LayoutTensor[mut=False, dtype, out_layout],
    a: LayoutTensor[mut=False, dtype, in_layout],
    size: Int,
):
    global_i = block_dim.x * block_idx.x + thread_idx.x
    local_i = thread_idx.x
    # FILL ME IN (roughly 20 lines)


# Kernel 2: Add block sums to their respective blocks
fn prefix_sum_block_sum_phase[
    layout: Layout
](output: LayoutTensor[mut=False, dtype, layout], size: Int):
    global_i = block_dim.x * block_idx.x + thread_idx.x
    # FILL ME IN (roughly 3 lines)


</code></pre>
<p><a href="https://github.com/modular/mojo-gpu-puzzles/blob/main/problems/p14/p14.mojo" class="filename">View full file: problems/p14/p14.mojo</a></p>
<p>The key to this puzzle is understanding that <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/barrier/">barrier</a> only synchronizes threads within a block, not across blocks. For cross-block synchronization, you need to use host-level synchronization:</p>
<pre><code class="language-mojo">            # Phase 1: Local prefix sums
            ctx.enqueue_function[
                prefix_sum_local_phase[extended_layout, extended_layout]
            ](
                out_tensor,
                a_tensor,
                size,
                grid_dim=BLOCKS_PER_GRID_2,
                block_dim=THREADS_PER_BLOCK_2,
            )

            # Phase 2: Add block sums
            ctx.enqueue_function[prefix_sum_block_sum_phase[extended_layout]](
                out_tensor,
                size,
                grid_dim=BLOCKS_PER_GRID_2,
                block_dim=THREADS_PER_BLOCK_2,
            )
</code></pre>
<details>
<summary><strong>Tips</strong></summary>
<div class="solution-tips">
<h3 id="1-build-on-the-simple-prefix-sum"><a class="header" href="#1-build-on-the-simple-prefix-sum">1. Build on the simple prefix sum</a></h3>
<p>The <a href="./simple.html">Simple Version</a> shows how to implement a single-block prefix sum. You‚Äôll need to extend that approach to work across multiple blocks:</p>
<pre><code>Simple version (single block): [0,1,2,3,4,5,6,7] ‚Üí [0,1,3,6,10,15,21,28]

Complete version (two blocks):
Block 0: [0,1,2,3,4,5,6,7] ‚Üí [0,1,3,6,10,15,21,28]
Block 1: [8,9,10,11,12,13,14] ‚Üí [8,17,27,38,50,63,77]
</code></pre>
<p>But how do we handle the second block‚Äôs values? They need to include sums from the first block!</p>
<h3 id="2-two-phase-approach"><a class="header" href="#2-two-phase-approach">2. Two-phase approach</a></h3>
<p>The simple prefix sum can‚Äôt synchronize across blocks, so split the work:</p>
<ol>
<li><strong>First phase</strong>: Each block computes its own local prefix sum (just like the simple version)</li>
<li><strong>Second phase</strong>: Blocks incorporate the sums from previous blocks</li>
</ol>
<p>Remember: <code>barrier()</code> only synchronizes threads within one block. You need host-level synchronization between phases.</p>
<h3 id="3-extended-memory-strategy"><a class="header" href="#3-extended-memory-strategy">3. Extended memory strategy</a></h3>
<p>Since blocks can‚Äôt directly communicate, you need somewhere to store block sums:</p>
<ul>
<li>Allocate extra memory at the end of your output buffer</li>
<li>Last thread in each block stores its final sum in this extra space</li>
<li>Subsequent blocks can read these sums and add them to their elements</li>
</ul>
<h3 id="4-key-implementation-insights"><a class="header" href="#4-key-implementation-insights">4. Key implementation insights</a></h3>
<ul>
<li><strong>Different layouts</strong>: Input and output may have different shapes</li>
<li><strong>Boundary handling</strong>: Always check <code>global_i &lt; size</code> for array bounds</li>
<li><strong>Thread role specialization</strong>: Only specific threads (e.g., last thread) should store block sums</li>
<li><strong>Two kernel synchronization</strong>: Use <code>ctx.synchronize()</code> between kernel launches</li>
</ul>
<h3 id="5-debugging-strategy"><a class="header" href="#5-debugging-strategy">5. Debugging Strategy</a></h3>
<p>If you encounter issues, try visualizing the intermediate state after the first phase:</p>
<pre><code>After first phase: [0,1,3,6,10,15,21,28, 8,17,27,38,50,63,77, ???,???]
</code></pre>
<p>Where <code>???</code> should contain your block sums that will be used in the second phase.</p>
</div>
</details>
<h3 id="running-the-code"><a class="header" href="#running-the-code">Running the code</a></h3>
<p>To test your solution, run the following command in your terminal:</p>
<div class="code-tabs" data-tab-group="package-manager">
  <div class="tab-buttons">
    <button class="tab-button">pixi NVIDIA (default)</button>
    <button class="tab-button">pixi AMD</button>
    <button class="tab-button">pixi Apple</button>
    <button class="tab-button">uv</button>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p14 --complete
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p14 --complete -e amd
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p14 --complete -e apple
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">uv run poe p14 --complete
</code></pre>
  </div>
</div>
<p>Your output will look like this if the puzzle isn‚Äôt solved yet:</p>
<pre><code class="language-txt">out: HostBuffer([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
expected: HostBuffer([0.0, 1.0, 3.0, 6.0, 10.0, 15.0, 21.0, 28.0, 36.0, 45.0, 55.0, 66.0, 78.0, 91.0, 105.0])
</code></pre>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<details class="solution-details">
<summary></summary>
<pre><code class="language-mojo">

# Kernel 1: Compute local prefix sums and store block sums in out
fn prefix_sum_local_phase[
    out_layout: Layout, in_layout: Layout
](
    output: LayoutTensor[mut=False, dtype, out_layout],
    a: LayoutTensor[mut=False, dtype, in_layout],
    size: Int,
):
    global_i = block_dim.x * block_idx.x + thread_idx.x
    local_i = thread_idx.x
    shared = tb[dtype]().row_major[TPB]().shared().alloc()

    # Load data into shared memory
    # Example with SIZE_2=15, TPB=8, BLOCKS=2:
    # Block 0 shared mem: [0,1,2,3,4,5,6,7]
    # Block 1 shared mem: [8,9,10,11,12,13,14,uninitialized]
    # Note: The last position remains uninitialized since global_i &gt;= size,
    # but this is safe because that thread doesn't participate in computation
    if global_i &lt; size:
        shared[local_i] = a[global_i]

    barrier()

    # Compute local prefix sum using parallel reduction
    # This uses a tree-based algorithm with log(TPB) iterations
    # Iteration 1 (offset=1):
    #   Block 0: [0,0+1,2+1,3+2,4+3,5+4,6+5,7+6] = [0,1,3,5,7,9,11,13]
    # Iteration 2 (offset=2):
    #   Block 0: [0,1,3+0,5+1,7+3,9+5,11+7,13+9] = [0,1,3,6,10,14,18,22]
    # Iteration 3 (offset=4):
    #   Block 0: [0,1,3,6,10+0,14+1,18+3,22+6] = [0,1,3,6,10,15,21,28]
    #   Block 1 follows same pattern to get [8,17,27,38,50,63,77,???]
    offset = 1
    for i in range(Int(log2(Scalar[dtype](TPB)))):
        var current_val: output.element_type = 0
        if local_i &gt;= offset and local_i &lt; TPB:
            current_val = shared[local_i - offset]  # read

        barrier()
        if local_i &gt;= offset and local_i &lt; TPB:
            shared[local_i] += current_val  # write

        barrier()
        offset *= 2

    # Write local results to output
    # Block 0 writes: [0,1,3,6,10,15,21,28]
    # Block 1 writes: [8,17,27,38,50,63,77,???]
    if global_i &lt; size:
        output[global_i] = shared[local_i]

    # Store block sums in auxiliary space
    # Block 0: Thread 7 stores shared[7] == 28 at position size+0 (position 15)
    # Block 1: Thread 7 stores shared[7] == ??? at position size+1 (position 16).  This sum is not needed for the final output.
    # This gives us: [0,1,3,6,10,15,21,28, 8,17,27,38,50,63,77, 28,???]
    #                                                           ‚Üë  ‚Üë
    #                                                     Block sums here
    if local_i == TPB - 1:
        output[size + block_idx.x] = shared[local_i]


# Kernel 2: Add block sums to their respective blocks
fn prefix_sum_block_sum_phase[
    layout: Layout
](output: LayoutTensor[mut=False, dtype, layout], size: Int):
    global_i = block_dim.x * block_idx.x + thread_idx.x

    # Second pass: add previous block's sum to each element
    # Block 0: No change needed - already correct
    # Block 1: Add Block 0's sum (28) to each element
    #   Before: [8,17,27,38,50,63,77]
    #   After: [36,45,55,66,78,91,105]
    # Final result combines both blocks:
    # [0,1,3,6,10,15,21,28, 36,45,55,66,78,91,105]
    if block_idx.x &gt; 0 and global_i &lt; size:
        prev_block_sum = output[size + block_idx.x - 1]
        output[global_i] += prev_block_sum


</code></pre>
<div class="solution-explanation">
<p>This solution implements a multi-block prefix sum using a two-kernel approach to handle an array that spans multiple thread blocks. Let‚Äôs break down each aspect in detail:</p>
<h2 id="the-challenge-of-cross-block-communication"><a class="header" href="#the-challenge-of-cross-block-communication">The challenge of cross-block communication</a></h2>
<p>The fundamental limitation in GPU programming is that threads can only synchronize within a block using <code>barrier()</code>. When data spans multiple blocks, we face the challenge: <strong>How do we ensure blocks can communicate their partial results to other blocks?</strong></p>
<h3 id="memory-layout-visualization"><a class="header" href="#memory-layout-visualization">Memory layout visualization</a></h3>
<p>For our test case with <code>SIZE_2 = 15</code> and <code>TPB = 8</code>:</p>
<pre><code>Input array:  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]

Block 0 processes: [0, 1, 2, 3, 4, 5, 6, 7]
Block 1 processes: [8, 9, 10, 11, 12, 13, 14] (7 valid elements)
</code></pre>
<p>We extend the output buffer to include space for block sums:</p>
<pre><code>Extended buffer: [data values (15 elements)] + [block sums (2 elements)]
                 [0...14] + [block0_sum, block1_sum]
</code></pre>
<p>The size of this extended buffer is: <code>EXTENDED_SIZE = SIZE_2 + num_blocks = 15 + 2 = 17</code></p>
<h2 id="phase-1-kernel-local-prefix-sums"><a class="header" href="#phase-1-kernel-local-prefix-sums">Phase 1 kernel: Local prefix sums</a></h2>
<h3 id="race-condition-prevention-in-local-phase"><a class="header" href="#race-condition-prevention-in-local-phase">Race condition prevention in local phase</a></h3>
<p>The local phase uses the same explicit synchronization pattern as the simple version to prevent read-write hazards:</p>
<ul>
<li><strong>Read Phase</strong>: All threads first read the values they need into a local variable <code>current_val</code></li>
<li><strong>Synchronization</strong>: <code>barrier()</code> ensures all reads complete before any writes begin</li>
<li><strong>Write Phase</strong>: All threads then safely write their computed values back to shared memory</li>
</ul>
<p>This prevents race conditions that could occur when multiple threads simultaneously access the same shared memory locations during the parallel reduction.</p>
<h3 id="step-by-step-execution-for-block-0"><a class="header" href="#step-by-step-execution-for-block-0">Step-by-step execution for Block 0</a></h3>
<ol>
<li>
<p><strong>Load values into shared memory</strong>:</p>
<pre><code>shared = [0, 1, 2, 3, 4, 5, 6, 7]
</code></pre>
</li>
<li>
<p><strong>Iterations of parallel reduction</strong> (\(\log_2(TPB) = 3\) iterations):</p>
<p><strong>Iteration 1</strong> (offset=1):</p>
<p><strong>Read Phase</strong>: Each active thread reads the value it needs:</p>
<pre><code>T‚ÇÅ reads shared[0] = 0    T‚ÇÖ reads shared[4] = 4
T‚ÇÇ reads shared[1] = 1    T‚ÇÜ reads shared[5] = 5
T‚ÇÉ reads shared[2] = 2    T‚Çá reads shared[6] = 6
T‚ÇÑ reads shared[3] = 3
</code></pre>
<p><strong>Synchronization</strong>: <code>barrier()</code> ensures all reads complete</p>
<p><strong>Write Phase</strong>: Each thread adds its read value:</p>
<pre><code>shared[0] = 0              (unchanged)
shared[1] = 1 + 0 = 1
shared[2] = 2 + 1 = 3
shared[3] = 3 + 2 = 5
shared[4] = 4 + 3 = 7
shared[5] = 5 + 4 = 9
shared[6] = 6 + 5 = 11
shared[7] = 7 + 6 = 13
</code></pre>
<p>After barrier: <code>shared = [0, 1, 3, 5, 7, 9, 11, 13]</code></p>
<p><strong>Iteration 2</strong> (offset=2):</p>
<p><strong>Read Phase</strong>: Each active thread reads the value it needs:</p>
<pre><code>T‚ÇÇ reads shared[0] = 0    T‚ÇÖ reads shared[3] = 5
T‚ÇÉ reads shared[1] = 1    T‚ÇÜ reads shared[4] = 7
T‚ÇÑ reads shared[2] = 3    T‚Çá reads shared[5] = 9
</code></pre>
<p><strong>Synchronization</strong>: <code>barrier()</code> ensures all reads complete</p>
<p><strong>Write Phase</strong>: Each thread adds its read value:</p>
<pre><code>shared[0] = 0              (unchanged)
shared[1] = 1              (unchanged)
shared[2] = 3 + 0 = 3      (unchanged)
shared[3] = 5 + 1 = 6
shared[4] = 7 + 3 = 10
shared[5] = 9 + 5 = 14
shared[6] = 11 + 7 = 18
shared[7] = 13 + 9 = 22
</code></pre>
<p>After barrier: <code>shared = [0, 1, 3, 6, 10, 14, 18, 22]</code></p>
<p><strong>Iteration 3</strong> (offset=4):</p>
<p><strong>Read Phase</strong>: Each active thread reads the value it needs:</p>
<pre><code>T‚ÇÑ reads shared[0] = 0    T‚ÇÜ reads shared[2] = 3
T‚ÇÖ reads shared[1] = 1    T‚Çá reads shared[3] = 6
</code></pre>
<p><strong>Synchronization</strong>: <code>barrier()</code> ensures all reads complete</p>
<p><strong>Write Phase</strong>: Each thread adds its read value:</p>
<pre><code>shared[0] = 0              (unchanged)
shared[1] = 1              (unchanged)
shared[2] = 3              (unchanged)
shared[3] = 6              (unchanged)
shared[4] = 10 + 0 = 10    (unchanged)
shared[5] = 14 + 1 = 15
shared[6] = 18 + 3 = 21
shared[7] = 22 + 6 = 28
</code></pre>
<p>After barrier: <code>shared = [0, 1, 3, 6, 10, 15, 21, 28]</code></p>
</li>
<li>
<p><strong>Write local results back to global memory</strong>:</p>
<pre><code>output[0...7] = [0, 1, 3, 6, 10, 15, 21, 28]
</code></pre>
</li>
<li>
<p><strong>Store block sum in auxiliary space</strong> (only last thread):</p>
<pre><code>output[15] = 28  // at position size + block_idx.x = 15 + 0
</code></pre>
</li>
</ol>
<h3 id="step-by-step-execution-for-block-1"><a class="header" href="#step-by-step-execution-for-block-1">Step-by-step execution for Block 1</a></h3>
<ol>
<li>
<p><strong>Load values into shared memory</strong>:</p>
<pre><code>shared = [8, 9, 10, 11, 12, 13, 14, uninitialized]
</code></pre>
<p>Note: Thread 7 doesn‚Äôt load anything since <code>global_i = 15 &gt;= SIZE_2</code>, leaving <code>shared[7]</code> uninitialized. This is safe because Thread 7 won‚Äôt participate in the final output.</p>
</li>
<li>
<p><strong>Iterations of parallel reduction</strong> (\(\log_2(TPB) = 3\) iterations):</p>
<p>Only the first 7 threads participate in meaningful computation. After all three iterations:</p>
<pre><code>shared = [8, 17, 27, 38, 50, 63, 77, uninitialized]
</code></pre>
</li>
<li>
<p><strong>Write local results back to global memory</strong>:</p>
<pre><code>output[8...14] = [8, 17, 27, 38, 50, 63, 77]  // Only 7 valid outputs
</code></pre>
</li>
<li>
<p><strong>Store block sum in auxiliary space</strong> (only last thread in block):</p>
<pre><code>output[16] = shared[7]  // Thread 7 (TPB-1) stores whatever is in shared[7]
</code></pre>
<p>Note: Even though Thread 7 doesn‚Äôt load valid input data, it still participates in the prefix sum computation within the block. The <code>shared[7]</code> position gets updated during the parallel reduction iterations, but since it started uninitialized, the final value is unpredictable. However, this doesn‚Äôt affect correctness because Block 1 is the last block, so this block sum is never used in Phase 2.</p>
</li>
</ol>
<p>After Phase 1, the output buffer contains:</p>
<pre><code>[0, 1, 3, 6, 10, 15, 21, 28, 8, 17, 27, 38, 50, 63, 77, 28, ???]
                                                        ^   ^
                                                Block sums stored here
</code></pre>
<p>Note: The last block sum (???) is unpredictable since it‚Äôs based on uninitialized memory, but this doesn‚Äôt affect the final result.</p>
<h2 id="host-device-synchronization-when-its-actually-needed"><a class="header" href="#host-device-synchronization-when-its-actually-needed">Host-device synchronization: When it‚Äôs actually needed</a></h2>
<p>The two kernel phases execute sequentially <strong>without any explicit synchronization</strong> between them:</p>
<pre><code class="language-mojo"># Phase 1: Local prefix sums
ctx.enqueue_function[prefix_sum_local_phase[...]](...)

# Phase 2: Add block sums (automatically waits for Phase 1)
ctx.enqueue_function[prefix_sum_block_sum_phase[...]](...)
</code></pre>
<p><strong>Key insight</strong>: Mojo‚Äôs <code>DeviceContext</code> uses a single execution stream (CUDA stream on NVIDIA GPUs, HIP stream on AMD ROCm GPUs), which guarantees that kernel launches execute in the exact order they are enqueued. No explicit synchronization is needed between kernels.</p>
<p><strong>When <code>ctx.synchronize()</code> is needed</strong>:</p>
<pre><code class="language-mojo"># After both kernels complete, before reading results on host
ctx.synchronize()  # Host waits for GPU to finish

with out.map_to_host() as out_host:  # Now safe to read GPU results
    print("out:", out_host)
</code></pre>
<p>The <code>ctx.synchronize()</code> call serves its traditional purpose:</p>
<ul>
<li><strong>Host-device synchronization</strong>: Ensures the host waits for all GPU work to complete before accessing results</li>
<li><strong>Memory safety</strong>: Prevents reading GPU memory before computations finish</li>
</ul>
<p><strong>Execution model</strong>: Unlike <code>barrier()</code> which synchronizes threads within a block, kernel ordering comes from Mojo‚Äôs single-stream execution model, while <code>ctx.synchronize()</code> handles host-device coordination.</p>
<h2 id="phase-2-kernel-block-sum-addition"><a class="header" href="#phase-2-kernel-block-sum-addition">Phase 2 kernel: Block sum addition</a></h2>
<ol>
<li>
<p><strong>Block 0</strong>: No changes needed (it‚Äôs already correct).</p>
</li>
<li>
<p><strong>Block 1</strong>: Each thread adds Block 0‚Äôs sum to its element:</p>
<pre><code>prev_block_sum = output[size + block_idx.x - 1] = output[15] = 28
output[global_i] += prev_block_sum
</code></pre>
<p>Block 1 values are transformed:</p>
<pre><code>Before: [8, 17, 27, 38, 50, 63, 77]
After:  [36, 45, 55, 66, 78, 91, 105]
</code></pre>
</li>
</ol>
<h2 id="performance-and-optimization-considerations"><a class="header" href="#performance-and-optimization-considerations">Performance and optimization considerations</a></h2>
<h3 id="key-implementation-details"><a class="header" href="#key-implementation-details">Key implementation details</a></h3>
<p><strong>Local phase synchronization pattern</strong>: Each iteration within a block follows a strict read ‚Üí sync ‚Üí write pattern:</p>
<ol>
<li><code>var current_val: out.element_type = 0</code> - Initialize local variable</li>
<li><code>current_val = shared[local_i - offset]</code> - Read phase (if conditions met)</li>
<li><code>barrier()</code> - Explicit synchronization to prevent race conditions</li>
<li><code>shared[local_i] += current_val</code> - Write phase (if conditions met)</li>
<li><code>barrier()</code> - Standard synchronization before next iteration</li>
</ol>
<p><strong>Cross-block synchronization</strong>: The algorithm uses two levels of synchronization:</p>
<ul>
<li><strong>Intra-block</strong>: <code>barrier()</code> synchronizes threads within each block during local prefix sum computation</li>
<li><strong>Inter-block</strong>: <code>ctx.synchronize()</code> synchronizes between kernel launches to ensure Phase 1 completes before Phase 2 begins</li>
</ul>
<p><strong>Race condition prevention</strong>: The explicit read-write separation in the local phase prevents the race condition that would occur if threads simultaneously read from and write to the same shared memory locations during parallel reduction.</p>
<ol>
<li>
<p><strong>Work efficiency</strong>: This implementation has \(O(n \log n)\) work complexity, while the sequential algorithm is \(O(n)\). This is a classic space-time tradeoff in parallel algorithms.</p>
</li>
<li>
<p><strong>Memory overhead</strong>: The extra space for block sums is minimal (just one element per block).</p>
</li>
</ol>
<p>This two-kernel approach is a fundamental pattern in GPU programming for algorithms that require cross-block communication. The same strategy can be applied to other parallel algorithms like radix sort, histogram calculation, and reduction operations.</p>
</div>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../puzzle_14/simple.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../puzzle_15/puzzle_15.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../puzzle_14/simple.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../puzzle_15/puzzle_15.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/mojolang.js"></script>
        <script src="../theme/sidebar.js"></script>
        <script src="../theme/solution.js"></script>
        <script src="../theme/init-amplitude.js"></script>
        <script src="../theme/tabs.js"></script>


    </div>
    </body>
</html>
