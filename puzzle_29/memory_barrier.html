<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Double-Buffered Stencil Computation - Mojo ðŸ”¥ GPU Puzzles</title>


        <!-- Custom HTML head -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
            rel="stylesheet">
        
        <script src="https://unpkg.com/@lottiefiles/lottie-player@latest/dist/lottie-player.js"></script>
        
        <link rel="stylesheet" href="../theme/css/custom.css">
        <link rel="stylesheet" href="../theme/css/highlight.css">
        <link rel="stylesheet" id="theme">
        
        <!-- Additional meta tags -->
        <meta property="og:title" content="MojoðŸ”¥ GPU Puzzles">
        <meta property="og:description" content="Learn GPU Programming in MojoðŸ”¥ Through Interactive Puzzles">
        <meta property="og:image" content="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">
        <meta property="og:url" content="https://puzzles.modular.com/">
        <meta name="twitter:card" content="summary">
        <meta name="twitter:image:alt" content="Mojo GPU Puzzles Logo">
        <meta name="twitter:title" content="MojoðŸ”¥ GPU Puzzles">
        <meta name="twitter:description" content="Learn GPU Programming in MojoðŸ”¥ Through Interactive Puzzles">
        <meta name="twitter:image" content="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">
        <link rel="icon" type="image/png" href="https://puzzles.modular.com/puzzles_images/puzzle-mark.png">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/css/custom.css">
        <link rel="stylesheet" href="../theme/css/highlight.css">
        <link rel="stylesheet" href="../theme/css/tabs.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <button class="collapse-sidebar" aria-label="Collapse sidebar"></button>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Toggle color mode and talk to us buttons -->
        <script>
            document.addEventListener('click', function (event) {
                if (!event.target.matches('.theme-toggle')) return;
                event.preventDefault();
                const prevTheme = theme;
                html.classList.remove(theme);
                const newTheme = prevTheme === 'ayu' ? 'light' : 'ayu'
                html.classList.add(newTheme);
                theme = newTheme
                localStorage.setItem('mdbook-theme', theme);
            }, false);
            document.addEventListener('click', function() {
                if (!event.target.matches('.log-in')) return;
                event.preventDefault();
                window.amplitude.logEvent('LoginClickedFromPuzzles');
                window.open('https://developer.modular.com', '_blank');
            });
        </script>

        <div class="page-header">
            <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                <i class="fa fa-bars"></i>
            </label>
            <div id="menu-bar" class="menu-bar">
                <div class="left-buttons">
                    <div class="logo-section">
                        <a class="desktop-logo-link" href="https://modular.com"></a>
                        <a class="mobile-logo-link" href="https://builds.modular.com"></a>
                        <div class="slash">/</div>
                        <a class="internal-link" ref="/">Puzzles</a>
                    </div>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Dark</button></li>
                        </ul>
                    </div>
                <div class="right-buttons">
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button theme-toggle-btn" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="false" aria-expanded="false">
                        <i class="theme-toggle"></i>
                    </button>
                    <a class="menu-btn print" href="../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a class="menu-btn" href="https://github.com/modular/mojo-gpu-puzzles" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-github"></i>
                    </a>
                </div>
            </div>
        </div>

        <div id="page-wrapper" class="page-wrapper">
            <div class="page">

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <div id="content" class="content">
                    <main>
                        <h1 id="double-buffered-stencil-computation"><a class="header" href="#double-buffered-stencil-computation">Double-Buffered Stencil Computation</a></h1>
<blockquote>
<p><strong>ðŸ”¬ Fine-Grained Synchronization: mbarrier vs barrier()</strong></p>
<p>This puzzle introduces <strong>explicit memory barrier APIs</strong> that provide significantly more control than the basic <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#barrier"><code>barrier()</code></a> function used in previous puzzles.</p>
<p><strong>Basic <code>barrier()</code> limitations:</strong></p>
<ul>
<li><strong>Fire-and-forget</strong>: Single synchronization point with no state tracking</li>
<li><strong>Block-wide only</strong>: All threads in the block must participate simultaneously</li>
<li><strong>No reusability</strong>: Each barrier() call creates a new synchronization event</li>
<li><strong>Coarse-grained</strong>: Limited control over memory ordering and timing</li>
<li><strong>Static coordination</strong>: Cannot adapt to different thread participation patterns</li>
</ul>
<p><strong>Advanced <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/"><code>mbarrier APIs</code></a> capabilities:</strong></p>
<ul>
<li><strong>Precise control</strong>: <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_init"><code>mbarrier_init()</code></a> sets up reusable barrier objects with specific thread counts</li>
<li><strong>State tracking</strong>: <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_arrive"><code>mbarrier_arrive()</code></a> signals individual thread completion and maintains arrival count</li>
<li><strong>Flexible waiting</strong>: <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_test_wait"><code>mbarrier_test_wait()</code></a> allows threads to wait for specific completion states</li>
<li><strong>Reusable objects</strong>: Same barrier can be reinitialized and reused across multiple iterations</li>
<li><strong>Multiple barriers</strong>: Different barrier objects for different synchronization points (initialization, iteration, finalization)</li>
<li><strong>Hardware optimization</strong>: Maps directly to GPU hardware synchronization primitives for better performance</li>
<li><strong>Memory semantics</strong>: Explicit control over memory visibility and ordering guarantees</li>
</ul>
<p><strong>Why this matters for iterative algorithms:</strong>
In double-buffering patterns, you need <strong>precise coordination</strong> between buffer swap phases. Basic <code>barrier()</code> cannot provide the fine-grained control required for:</p>
<ul>
<li><strong>Buffer role alternation</strong>: Ensuring all writes to buffer_A complete before reading from buffer_A begins</li>
<li><strong>Iteration boundaries</strong>: Coordinating multiple synchronization points within a single kernel</li>
<li><strong>State management</strong>: Tracking which threads have completed which phase of processing</li>
<li><strong>Performance optimization</strong>: Minimizing synchronization overhead through reusable barrier objects</li>
</ul>
<p>This puzzle demonstrates <strong>synchronization patterns</strong> used in real-world GPU computing applications like iterative solvers, simulation frameworks, and high-performance image processing pipelines.</p>
</blockquote>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Implement a kernel that performs iterative stencil operations using double-buffered shared memory, coordinated with explicit memory barriers to ensure safe buffer swapping between iterations. A stencil operation is a computational pattern where the value of each element in an array is calculated based on a fixed pattern of its neighbors.</p>
<p><strong>Note:</strong> <em>You have alternating buffer roles: <code>buffer_A</code> and <code>buffer_B</code> swap between read and write operations each iteration, with mbarrier synchronization ensuring all threads complete writes before buffer swaps.</em></p>
<p><strong>Algorithm architecture:</strong> This puzzle implements a <strong>double-buffering pattern</strong> where two shared memory buffers alternate roles as read and write targets across multiple iterations. Unlike simple stencil operations that process data once, this approach performs iterative refinement with careful memory barrier coordination to prevent race conditions during buffer transitions.</p>
<p><strong>Pipeline concept:</strong> The algorithm processes data through iterative stencil refinement, where each iteration reads from one buffer and writes to another. The buffers alternate roles each iteration, creating a ping-pong pattern that enables continuous processing without data corruption.</p>
<p><strong>Data dependencies and synchronization:</strong> Each iteration depends on the complete results of the previous iteration:</p>
<ul>
<li><strong>Iteration N â†’ Iteration N+1</strong>: Current iteration produces refined data that next iteration consumes</li>
<li><strong>Buffer coordination</strong>: Read and write buffers swap roles each iteration</li>
<li><strong>Memory barriers prevent race conditions</strong> by ensuring all writes complete before any thread begins reading from the newly written buffer</li>
</ul>
<p>Concretely, the double-buffered stencil implements an iterative smoothing algorithm with three mathematical operations:</p>
<p><strong>Iteration Pattern - Buffer Alternation:</strong></p>
<p>\[\text{Iteration } i: \begin{cases}
\text{Read from buffer_A, Write to buffer_B} &amp; \text{if } i \bmod 2 = 0 \\
\text{Read from buffer_B, Write to buffer_A} &amp; \text{if } i \bmod 2 = 1
\end{cases}\]</p>
<p><strong>Stencil Operation - 3-Point Average:</strong></p>
<p>\[S^{(i+1)}[j] = \frac{1}{N_j} \sum_{k=-1}^{1} S^{(i)}[j+k] \quad \text{where } j+k \in [0, 255]\]</p>
<p>where \(S^{(i)}[j]\) is the stencil value at position \(j\) after iteration \(i\), and \(N_j\) is the count of valid neighbors.</p>
<p><strong>Memory Barrier Coordination:</strong></p>
<p>\[\text{mbarrier_arrive}() \Rightarrow \text{mbarrier_test_wait}() \Rightarrow \text{buffer swap} \Rightarrow \text{next iteration}\]</p>
<p><strong>Final Output Selection:</strong></p>
<p>\[\text{Output}[j] = \begin{cases}
\text{buffer_A}[j] &amp; \text{if STENCIL_ITERATIONS } \bmod 2 = 0 \\
\text{buffer_B}[j] &amp; \text{if STENCIL_ITERATIONS } \bmod 2 = 1
\end{cases}\]</p>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key concepts</a></h2>
<p>In this puzzle, youâ€™ll learn about:</p>
<ul>
<li>Implementing double-buffering patterns for iterative algorithms</li>
<li>Coordinating explicit memory barriers using <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/">mbarrier APIs</a></li>
<li>Managing alternating read/write buffer roles across iterations</li>
</ul>
<p>The key insight is understanding how to safely coordinate buffer swapping in iterative algorithms where race conditions between read and write operations can corrupt data if not properly synchronized.</p>
<p><strong>Why this matters:</strong> Most GPU tutorials show simple one-pass algorithms, but real-world applications often require <strong>iterative refinement</strong> with multiple passes over data. Double-buffering is essential for algorithms like iterative solvers, image processing filters, and simulation updates where each iteration depends on the complete results of the previous iteration.</p>
<p><strong>Previous vs. current synchronization:</strong></p>
<ul>
<li><strong>Previous puzzles (<a href="../puzzle_08/puzzle_08.html">P8</a>, <a href="../puzzle_12/puzzle_12.html">P12</a>, <a href="../puzzle_15/puzzle_15.html">P15</a>):</strong> Simple <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#barrier"><code>barrier()</code></a> calls for single-pass algorithms</li>
<li><strong>This puzzle:</strong> Explicit <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/">mbarrier APIs</a> for precise control over buffer swap timing</li>
</ul>
<p><strong>Memory barrier specialization:</strong> Unlike basic thread synchronization, this puzzle uses <strong>explicit memory barriers</strong> that provide fine-grained control over when memory operations complete, essential for complex memory access patterns.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p><strong>System parameters:</strong></p>
<ul>
<li><strong>Image size</strong>: <code>SIZE = 1024</code> elements (1D for simplicity)</li>
<li><strong>Threads per block</strong>: <code>TPB = 256</code> threads organized as <code>(256, 1)</code> block dimension</li>
<li><strong>Grid configuration</strong>: <code>(4, 1)</code> blocks to process entire image in tiles (4 blocks total)</li>
<li><strong>Data type</strong>: <code>DType.float32</code> for all computations</li>
</ul>
<p><strong>Iteration parameters:</strong></p>
<ul>
<li><strong>Stencil iterations</strong>: <code>STENCIL_ITERATIONS = 3</code> refinement passes</li>
<li><strong>Buffer count</strong>: <code>BUFFER_COUNT = 2</code> (double-buffering)</li>
<li><strong>Stencil kernel</strong>: 3-point averaging with radius 1</li>
</ul>
<p><strong>Buffer architecture:</strong></p>
<ul>
<li><strong>buffer_A</strong>: Primary shared memory buffer (<code>[256]</code> elements)</li>
<li><strong>buffer_B</strong>: Secondary shared memory buffer (<code>[256]</code> elements)</li>
<li><strong>Role alternation</strong>: Buffers swap between read source and write target each iteration</li>
</ul>
<p><strong>Processing requirements:</strong></p>
<p><strong>Initialization phase:</strong></p>
<ul>
<li><strong>Buffer setup</strong>: Initialize buffer_A with input data, buffer_B with zeros</li>
<li><strong>Barrier initialization</strong>: Set up <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_init">mbarrier objects</a> for synchronization points</li>
<li><strong>Thread coordination</strong>: All threads participate in initialization</li>
</ul>
<p><strong>Iterative processing:</strong></p>
<ul>
<li><strong>Even iterations</strong> (0, 2, 4â€¦): Read from buffer_A, write to buffer_B</li>
<li><strong>Odd iterations</strong> (1, 3, 5â€¦): Read from buffer_B, write to buffer_A</li>
<li><strong>Stencil operation</strong>: 3-point average \((\text{left} + \text{center} + \text{right}) / 3\)</li>
<li><strong>Boundary handling</strong>: Use adaptive averaging for elements at buffer edges</li>
</ul>
<p><strong>Memory barrier coordination:</strong></p>
<ul>
<li><strong><a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_arrive">mbarrier_arrive()</a></strong>: Each thread signals completion of write phase</li>
<li><strong><a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_test_wait">mbarrier_test_wait()</a></strong>: All threads wait until everyone completes writes</li>
<li><strong>Buffer swap safety</strong>: Prevents reading from buffer while others still writing</li>
<li><strong>Barrier reinitialization</strong>: Reset barrier state between iterations</li>
</ul>
<p><strong>Output phase:</strong></p>
<ul>
<li><strong>Final buffer selection</strong>: Choose active buffer based on iteration parity</li>
<li><strong>Global memory write</strong>: Copy final results to output array</li>
<li><strong>Completion barrier</strong>: Ensure all writes finish before block termination</li>
</ul>
<h2 id="code-to-complete"><a class="header" href="#code-to-complete">Code to complete</a></h2>
<pre><code class="language-mojo">
# Double-buffered stencil configuration
alias STENCIL_ITERATIONS = 3
alias BUFFER_COUNT = 2


fn double_buffered_stencil_computation[
    layout: Layout
](
    output: LayoutTensor[mut=True, dtype, layout],
    input: LayoutTensor[mut=False, dtype, layout],
    size: Int,
):
    """Double-buffered stencil computation with memory barrier coordination.

    Iteratively applies 3-point stencil using alternating buffers.
    Uses mbarrier APIs for precise buffer swap coordination.
    """

    # Double-buffering: Two shared memory buffers
    buffer_A = LayoutTensor[
        dtype,
        Layout.row_major(TPB),
        MutableAnyOrigin,
        address_space = AddressSpace.SHARED,
    ].stack_allocation()
    buffer_B = LayoutTensor[
        dtype,
        Layout.row_major(TPB),
        MutableAnyOrigin,
        address_space = AddressSpace.SHARED,
    ].stack_allocation()

    # Memory barriers for coordinating buffer swaps
    init_barrier = LayoutTensor[
        DType.uint64,
        Layout.row_major(1),
        MutableAnyOrigin,
        address_space = AddressSpace.SHARED,
    ].stack_allocation()
    iter_barrier = LayoutTensor[
        DType.uint64,
        Layout.row_major(1),
        MutableAnyOrigin,
        address_space = AddressSpace.SHARED,
    ].stack_allocation()
    final_barrier = LayoutTensor[
        DType.uint64,
        Layout.row_major(1),
        MutableAnyOrigin,
        address_space = AddressSpace.SHARED,
    ].stack_allocation()

    global_i = block_dim.x * block_idx.x + thread_idx.x
    local_i = thread_idx.x

    # Initialize barriers (only thread 0)
    if local_i == 0:
        mbarrier_init(init_barrier.ptr, TPB)
        mbarrier_init(iter_barrier.ptr, TPB)
        mbarrier_init(final_barrier.ptr, TPB)

    # Initialize buffer_A with input data

    # FILL ME IN (roughly 4 lines)

    # Wait for buffer_A initialization
    _ = mbarrier_arrive(init_barrier.ptr)
    _ = mbarrier_test_wait(init_barrier.ptr, TPB)

    # Iterative stencil processing with double-buffering
    @parameter
    for iteration in range(STENCIL_ITERATIONS):

        @parameter
        if iteration % 2 == 0:
            # Even iteration: Read from A, Write to B

            # FILL ME IN (roughly 12 lines)
            ...

        else:
            # Odd iteration: Read from B, Write to A

            # FILL ME IN (roughly 12 lines)
            ...

        # Memory barrier: wait for all writes before buffer swap
        _ = mbarrier_arrive(iter_barrier.ptr)
        _ = mbarrier_test_wait(iter_barrier.ptr, TPB)

        # Reinitialize barrier for next iteration
        if local_i == 0:
            mbarrier_init(iter_barrier.ptr, TPB)

    # Write final results from active buffer
    if local_i &lt; TPB and global_i &lt; size:

        @parameter
        if STENCIL_ITERATIONS % 2 == 0:
            # Even iterations end in buffer_A
            output[global_i] = buffer_A[local_i]
        else:
            # Odd iterations end in buffer_B
            output[global_i] = buffer_B[local_i]

    # Final barrier
    _ = mbarrier_arrive(final_barrier.ptr)
    _ = mbarrier_test_wait(final_barrier.ptr, TPB)


</code></pre>
<p><a href="https://github.com/modular/mojo-gpu-puzzles/blob/main/problems/p29/p29.mojo" class="filename">View full file: problems/p29/p29.mojo</a></p>
<details>
<summary><strong>Tips</strong></summary>
<div class="solution-tips">
<h3 id="buffer-initialization"><a class="header" href="#buffer-initialization"><strong>Buffer initialization</strong></a></h3>
<ul>
<li>Initialize <code>buffer_A</code> with input data, <code>buffer_B</code> can start empty</li>
<li>Use proper bounds checking with zero-padding for out-of-range elements</li>
<li>Only thread 0 should initialize the mbarrier objects</li>
<li>Set up separate barriers for different synchronization points</li>
</ul>
<h3 id="iteration-control"><a class="header" href="#iteration-control"><strong>Iteration control</strong></a></h3>
<ul>
<li>Use <code>@parameter for iteration in range(STENCIL_ITERATIONS)</code> for compile-time unrolling</li>
<li>Determine buffer roles using <code>iteration % 2</code> to alternate read/write assignments</li>
<li>Apply stencil operation only within valid bounds with neighbor checking</li>
</ul>
<h3 id="stencil-computation"><a class="header" href="#stencil-computation"><strong>Stencil computation</strong></a></h3>
<ul>
<li>Implement 3-point averaging: <code>(left + center + right) / 3</code></li>
<li>Handle boundary conditions by only including valid neighbors in average</li>
<li>Use adaptive counting to handle edge cases gracefully</li>
</ul>
<h3 id="memory-barrier-coordination"><a class="header" href="#memory-barrier-coordination"><strong>Memory barrier coordination</strong></a></h3>
<ul>
<li>Call <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_arrive"><code>mbarrier_arrive()</code></a> after each thread completes its write operations</li>
<li>Use <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_test_wait"><code>mbarrier_test_wait()</code></a> to ensure all threads finish before buffer swap</li>
<li>Reinitialize barriers between iterations for reuse: <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_init"><code>mbarrier_init()</code></a></li>
<li>Only thread 0 should reinitialize barriers to avoid race conditions</li>
</ul>
<h3 id="output-selection"><a class="header" href="#output-selection"><strong>Output selection</strong></a></h3>
<ul>
<li>Choose final active buffer based on <code>STENCIL_ITERATIONS % 2</code></li>
<li>Even iteration counts end with data in buffer_A</li>
<li>Odd iteration counts end with data in buffer_B</li>
<li>Write final results to global output with bounds checking</li>
</ul>
</div>
</details>
<h2 id="running-the-code"><a class="header" href="#running-the-code">Running the code</a></h2>
<p>To test your solution, run the following command in your terminal:</p>
<div class="code-tabs" data-tab-group="package-manager">
  <div class="tab-buttons">
    <button class="tab-button">pixi NVIDIA (default)</button>
    <button class="tab-button">pixi AMD</button>
    <button class="tab-button">uv</button>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p29 --double-buffer
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">pixi run p29 --double-buffer -e amd
</code></pre>
  </div>
  <div class="tab-content">
<pre><code class="language-bash">uv run poe p29 --double-buffer
</code></pre>
  </div>
</div>
<p>After completing the puzzle successfully, you should see output similar to:</p>
<pre><code>Puzzle 29: GPU Synchronization Primitives
==================================================
TPB: 256
SIZE: 1024
STENCIL_ITERATIONS: 3
BUFFER_COUNT: 2

Testing Puzzle 29B: Double-Buffered Stencil Computation
============================================================
Double-buffered stencil completed
Input sample: 1.0 1.0 1.0
GPU output sample: 1.0 1.0 1.0
âœ… Double-buffered stencil test PASSED!
</code></pre>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<details class="solution-details">
<summary></summary>
<pre><code class="language-mojo">fn double_buffered_stencil_computation[
    layout: Layout
](
    output: LayoutTensor[mut=True, dtype, layout],
    input: LayoutTensor[mut=False, dtype, layout],
    size: Int,
):
    """Double-buffered stencil computation with memory barrier coordination.

    Iteratively applies 3-point stencil using alternating buffers.
    Uses mbarrier APIs for precise buffer swap coordination.
    """

    # Double-buffering: Two shared memory buffers
    buffer_A = LayoutTensor[
        dtype,
        Layout.row_major(TPB),
        MutableAnyOrigin,
        address_space = AddressSpace.SHARED,
    ].stack_allocation()
    buffer_B = LayoutTensor[
        dtype,
        Layout.row_major(TPB),
        MutableAnyOrigin,
        address_space = AddressSpace.SHARED,
    ].stack_allocation()

    # Memory barriers for coordinating buffer swaps
    init_barrier = LayoutTensor[
        DType.uint64,
        Layout.row_major(1),
        MutableAnyOrigin,
        address_space = AddressSpace.SHARED,
    ].stack_allocation()
    iter_barrier = LayoutTensor[
        DType.uint64,
        Layout.row_major(1),
        MutableAnyOrigin,
        address_space = AddressSpace.SHARED,
    ].stack_allocation()
    final_barrier = LayoutTensor[
        DType.uint64,
        Layout.row_major(1),
        MutableAnyOrigin,
        address_space = AddressSpace.SHARED,
    ].stack_allocation()

    global_i = block_dim.x * block_idx.x + thread_idx.x
    local_i = thread_idx.x

    # Initialize barriers (only thread 0)
    if local_i == 0:
        mbarrier_init(init_barrier.ptr, TPB)
        mbarrier_init(iter_barrier.ptr, TPB)
        mbarrier_init(final_barrier.ptr, TPB)

    # Initialize buffer_A with input data
    if local_i &lt; TPB and global_i &lt; size:
        buffer_A[local_i] = input[global_i]
    else:
        buffer_A[local_i] = 0.0

    # Wait for buffer_A initialization
    _ = mbarrier_arrive(init_barrier.ptr)
    _ = mbarrier_test_wait(init_barrier.ptr, TPB)

    # Iterative stencil processing with double-buffering
    @parameter
    for iteration in range(STENCIL_ITERATIONS):

        @parameter
        if iteration % 2 == 0:
            # Even iteration: Read from A, Write to B
            if local_i &lt; TPB:
                var stencil_sum: Scalar[dtype] = 0.0
                var stencil_count: Int = 0

                # 3-point stencil: [i-1, i, i+1]
                for offset in range(-1, 2):
                    sample_idx = local_i + offset
                    if sample_idx &gt;= 0 and sample_idx &lt; TPB:
                        stencil_sum += rebind[Scalar[dtype]](
                            buffer_A[sample_idx]
                        )
                        stencil_count += 1

                if stencil_count &gt; 0:
                    buffer_B[local_i] = stencil_sum / stencil_count
                else:
                    buffer_B[local_i] = buffer_A[local_i]

        else:
            # Odd iteration: Read from B, Write to A
            if local_i &lt; TPB:
                var stencil_sum: Scalar[dtype] = 0.0
                var stencil_count: Int = 0

                # 3-point stencil: [i-1, i, i+1]
                for offset in range(-1, 2):
                    sample_idx = local_i + offset
                    if sample_idx &gt;= 0 and sample_idx &lt; TPB:
                        stencil_sum += rebind[Scalar[dtype]](
                            buffer_B[sample_idx]
                        )
                        stencil_count += 1

                if stencil_count &gt; 0:
                    buffer_A[local_i] = stencil_sum / stencil_count
                else:
                    buffer_A[local_i] = buffer_B[local_i]

        # Memory barrier: wait for all writes before buffer swap
        _ = mbarrier_arrive(iter_barrier.ptr)
        _ = mbarrier_test_wait(iter_barrier.ptr, TPB)

        # Reinitialize barrier for next iteration
        if local_i == 0:
            mbarrier_init(iter_barrier.ptr, TPB)

    # Write final results from active buffer
    if local_i &lt; TPB and global_i &lt; size:

        @parameter
        if STENCIL_ITERATIONS % 2 == 0:
            # Even iterations end in buffer_A
            output[global_i] = buffer_A[local_i]
        else:
            # Odd iterations end in buffer_B
            output[global_i] = buffer_B[local_i]

    # Final barrier
    _ = mbarrier_arrive(final_barrier.ptr)
    _ = mbarrier_test_wait(final_barrier.ptr, TPB)


</code></pre>
<div class="solution-explanation">
<p>The key insight is recognizing this as a <strong>double-buffering architecture problem</strong> with explicit memory barrier coordination:</p>
<ol>
<li><strong>Design alternating buffer roles</strong>: Swap read/write responsibilities each iteration</li>
<li><strong>Implement explicit memory barriers</strong>: Use mbarrier APIs for precise synchronization control</li>
<li><strong>Coordinate iterative processing</strong>: Ensure complete iteration results before buffer swaps</li>
<li><strong>Optimize memory access patterns</strong>: Keep all processing in fast shared memory</li>
</ol>
<details class="solution-details">
<p><strong>Complete Solution with Detailed Explanation</strong></p>
<p>The double-buffered stencil solution demonstrates sophisticated memory barrier coordination and iterative processing patterns. This approach enables safe iterative refinement algorithms that require precise control over memory access timing.</p>
<h2 id="double-buffering-architecture-design"><a class="header" href="#double-buffering-architecture-design"><strong>Double-buffering architecture design</strong></a></h2>
<p>The fundamental breakthrough in this puzzle is <strong>explicit memory barrier control</strong> rather than simple thread synchronization:</p>
<p><strong>Traditional approach:</strong> Use basic <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#barrier"><code>barrier()</code></a> for simple thread coordination</p>
<ul>
<li>All threads execute same operation on different data</li>
<li>Single barrier call synchronizes thread completion</li>
<li>No control over specific memory operation timing</li>
</ul>
<p><strong>This puzzleâ€™s innovation:</strong> Different buffer roles coordinated with explicit memory barriers</p>
<ul>
<li>buffer_A and buffer_B alternate between read source and write target</li>
<li><a href="https://docs.modular.com/mojo/stdlib/gpu/sync/">mbarrier APIs</a> provide precise control over memory operation completion</li>
<li>Explicit coordination prevents race conditions during buffer transitions</li>
</ul>
<h2 id="iterative-processing-coordination"><a class="header" href="#iterative-processing-coordination"><strong>Iterative processing coordination</strong></a></h2>
<p>Unlike single-pass algorithms, this establishes iterative refinement with careful buffer management:</p>
<ul>
<li><strong>Iteration 0</strong>: Read from buffer_A (initialized with input), write to buffer_B</li>
<li><strong>Iteration 1</strong>: Read from buffer_B (previous results), write to buffer_A</li>
<li><strong>Iteration 2</strong>: Read from buffer_A (previous results), write to buffer_B</li>
<li><strong>Continue alternating</strong>: Each iteration refines results from previous iteration</li>
</ul>
<h2 id="memory-barrier-api-usage"><a class="header" href="#memory-barrier-api-usage"><strong>Memory barrier API usage</strong></a></h2>
<p>Understanding the mbarrier coordination pattern:</p>
<ul>
<li><strong><a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_init">mbarrier_init()</a></strong>: Initialize barrier for specific thread count (TPB)</li>
<li><strong><a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_arrive">mbarrier_arrive()</a></strong>: Signal individual thread completion of write phase</li>
<li><strong><a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_test_wait">mbarrier_test_wait()</a></strong>: Block until all threads signal completion</li>
<li><strong>Reinitialization</strong>: Reset barrier state between iterations for reuse</li>
</ul>
<p><strong>Critical timing sequence:</strong></p>
<ol>
<li><strong>All threads write</strong>: Each thread updates its assigned buffer element</li>
<li><strong>Signal completion</strong>: Each thread calls <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_arrive"><code>mbarrier_arrive()</code></a></li>
<li><strong>Wait for all</strong>: All threads call <a href="https://docs.modular.com/mojo/stdlib/gpu/sync/#mbarrier_test_wait"><code>mbarrier_test_wait()</code></a></li>
<li><strong>Safe to proceed</strong>: Now safe to swap buffer roles for next iteration</li>
</ol>
<h2 id="stencil-operation-mechanics"><a class="header" href="#stencil-operation-mechanics"><strong>Stencil operation mechanics</strong></a></h2>
<p>The 3-point stencil operation with adaptive boundary handling:</p>
<p><strong>Interior elements</strong> (indices 1 to 254):</p>
<pre><code class="language-mojo"># Average with left, center, and right neighbors
stencil_sum = buffer[i-1] + buffer[i] + buffer[i+1]
result[i] = stencil_sum / 3.0
</code></pre>
<p><strong>Boundary elements</strong> (indices 0 and 255):</p>
<pre><code class="language-mojo"># Only include valid neighbors in average
stencil_count = 0
for neighbor in valid_neighbors:
    stencil_sum += buffer[neighbor]
    stencil_count += 1
result[i] = stencil_sum / stencil_count
</code></pre>
<h2 id="buffer-role-alternation"><a class="header" href="#buffer-role-alternation"><strong>Buffer role alternation</strong></a></h2>
<p>The ping-pong buffer pattern ensures data integrity:</p>
<p><strong>Even iterations</strong> (0, 2, 4â€¦):</p>
<ul>
<li><strong>Read source</strong>: buffer_A contains current data</li>
<li><strong>Write target</strong>: buffer_B receives updated results</li>
<li><strong>Memory flow</strong>: buffer_A â†’ stencil operation â†’ buffer_B</li>
</ul>
<p><strong>Odd iterations</strong> (1, 3, 5â€¦):</p>
<ul>
<li><strong>Read source</strong>: buffer_B contains current data</li>
<li><strong>Write target</strong>: buffer_A receives updated results</li>
<li><strong>Memory flow</strong>: buffer_B â†’ stencil operation â†’ buffer_A</li>
</ul>
<h2 id="race-condition-prevention"><a class="header" href="#race-condition-prevention"><strong>Race condition prevention</strong></a></h2>
<p>Memory barriers eliminate multiple categories of race conditions:</p>
<p><strong>Without barriers (broken)</strong>:</p>
<pre><code class="language-mojo"># Thread A writes to buffer_B[10]
buffer_B[10] = stencil_result_A

# Thread B immediately reads buffer_B[10] for its stencil
# RACE CONDITION: Thread B might read old value before Thread A's write completes
stencil_input = buffer_B[10]  // Undefined behavior!
</code></pre>
<p><strong>With barriers (correct)</strong>:</p>
<pre><code class="language-mojo"># All threads write their results
buffer_B[local_i] = stencil_result

# Signal write completion
mbarrier_arrive(barrier)

# Wait for ALL threads to complete writes
mbarrier_test_wait(barrier, TPB)

# Now safe to read - all writes guaranteed complete
stencil_input = buffer_B[neighbor_index]  // Always sees correct values
</code></pre>
<h2 id="output-buffer-selection"><a class="header" href="#output-buffer-selection"><strong>Output buffer selection</strong></a></h2>
<p>Final result location depends on iteration parity:</p>
<p><strong>Mathematical determination</strong>:</p>
<ul>
<li><strong>STENCIL_ITERATIONS = 3</strong> (odd number)</li>
<li><strong>Final active buffer</strong>: Iteration 2 writes to buffer_B</li>
<li><strong>Output source</strong>: Copy from buffer_B to global memory</li>
</ul>
<p><strong>Implementation pattern</strong>:</p>
<pre><code class="language-mojo">@parameter
if STENCIL_ITERATIONS % 2 == 0:
    # Even total iterations end in buffer_A
    output[global_i] = buffer_A[local_i]
else:
    # Odd total iterations end in buffer_B
    output[global_i] = buffer_B[local_i]
</code></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics"><strong>Performance characteristics</strong></a></h2>
<p><strong>Memory hierarchy optimization:</strong></p>
<ul>
<li><strong>Global memory</strong>: Accessed only for input loading and final output</li>
<li><strong>Shared memory</strong>: All iterative processing uses fast shared memory</li>
<li><strong>Register usage</strong>: Minimal due to shared memory focus</li>
</ul>
<p><strong>Synchronization overhead:</strong></p>
<ul>
<li><strong>mbarrier cost</strong>: Higher than basic barrier() but provides essential control</li>
<li><strong>Iteration scaling</strong>: Overhead increases linearly with iteration count</li>
<li><strong>Thread efficiency</strong>: All threads remain active throughout processing</li>
</ul>
<h2 id="real-world-applications"><a class="header" href="#real-world-applications"><strong>Real-world applications</strong></a></h2>
<p>This double-buffering pattern is fundamental to:</p>
<p><strong>Iterative solvers:</strong></p>
<ul>
<li>Gauss-Seidel and Jacobi methods for linear systems</li>
<li>Iterative refinement for numerical accuracy</li>
<li>Multigrid methods with level-by-level processing</li>
</ul>
<p><strong>Image processing:</strong></p>
<ul>
<li>Multi-pass filters (bilateral, guided, edge-preserving)</li>
<li>Iterative denoising algorithms</li>
<li>Heat diffusion and anisotropic smoothing</li>
</ul>
<p><strong>Simulation algorithms:</strong></p>
<ul>
<li>Cellular automata with state evolution</li>
<li>Particle systems with position updates</li>
<li>Fluid dynamics with iterative pressure solving</li>
</ul>
<h2 id="key-technical-insights"><a class="header" href="#key-technical-insights"><strong>Key technical insights</strong></a></h2>
<p><strong>Memory barrier philosophy:</strong></p>
<ul>
<li><strong>Explicit control</strong>: Precise timing control over memory operations vs automatic synchronization</li>
<li><strong>Race prevention</strong>: Essential for any algorithm with alternating read/write patterns</li>
<li><strong>Performance trade-off</strong>: Higher synchronization cost for guaranteed correctness</li>
</ul>
<p><strong>Double-buffering benefits:</strong></p>
<ul>
<li><strong>Data integrity</strong>: Eliminates read-while-write hazards</li>
<li><strong>Algorithm clarity</strong>: Clean separation between current and next iteration state</li>
<li><strong>Memory efficiency</strong>: No need for global memory intermediate storage</li>
</ul>
<p><strong>Iteration management:</strong></p>
<ul>
<li><strong>Compile-time unrolling</strong>: <code>@parameter for</code> enables optimization opportunities</li>
<li><strong>State tracking</strong>: Buffer role alternation must be deterministic</li>
<li><strong>Boundary handling</strong>: Adaptive stencil operations handle edge cases gracefully</li>
</ul>
<p>This solution demonstrates how to design iterative GPU algorithms that require precise memory access control, moving beyond simple parallel loops to sophisticated memory management patterns used in production numerical software.</p>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../puzzle_29/barrier.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../puzzle_30/puzzle_30.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../puzzle_29/barrier.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../puzzle_30/puzzle_30.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/mojolang.js"></script>
        <script src="../theme/sidebar.js"></script>
        <script src="../theme/solution.js"></script>
        <script src="../theme/init-amplitude.js"></script>
        <script src="../theme/tabs.js"></script>


    </div>
    </body>
</html>
